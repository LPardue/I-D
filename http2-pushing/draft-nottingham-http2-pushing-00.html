<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Defining HTTP/2 Server Push More Carefully</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(2);
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="../Tools/bower_components/bootstrap/dist/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul li {
        list-style: none;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Server Push and HTTP Semantics" href="#rfc.section.2"><link rel="Chapter" title="3 Generating PUSH_PROMISE" href="#rfc.section.3"><link rel="Chapter" title="4 Using Server Push Well" href="#rfc.section.4"><link rel="Chapter" title="5 Client Handling of Server Push" href="#rfc.section.5"><link rel="Chapter" title="6 IANA Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 Security Considerations" href="#rfc.section.7"><link rel="Chapter" href="#rfc.section.8" title="8 References"><link rel="Appendix" title="A Algorithm for Handling Pushes" href="#rfc.section.A"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="push"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-nottingham-http2-pushing-00"><meta name="dcterms.issued" content="2016-08-22"><meta name="dcterms.abstract" content="This document explores the use and implementation of HTTP/2 Server Push, in order to forumlate recommendations about use and implementation."><meta name="description" content="This document explores the use and implementation of HTTP/2 Server Push, in order to forumlate recommendations about use and implementation."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">Internet-Draft</a></div><br clear="all"><div class=""><div id="rfc..toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#server-push-and-http-semantics">Server Push and HTTP Semantics</a><ul><li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#http-methods">HTTP Methods</a></li><li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#http-status-codes">HTTP Status Codes</a></li><li><a href="#rfc.section.2.3">2.3</a>&nbsp;&nbsp;&nbsp;<a href="#conditional">Conditional Requests</a><ul><li><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#pushpromise-with-if-match-if-unmodified-since">PUSH_PROMISE with If-Match / If-Unmodified-Since</a></li><li><a href="#rfc.section.2.3.2">2.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#pushpromise-with-if-none-match-if-modified-since">PUSH_PROMISE with If-None-Match / If-Modified-Since</a></li><li><a href="#rfc.section.2.3.3">2.3.3</a>&nbsp;&nbsp;&nbsp;<a href="#generating-304-not-modified-without-a-conditional-in-pushpromise">Generating 304 (Not Modified) without a Conditional in PUSH_PROMISE</a></li></ul></li><li><a href="#rfc.section.2.4">2.4</a>&nbsp;&nbsp;&nbsp;<a href="#content-negotiation">Content Negotiation</a></li><li><a href="#rfc.section.2.5">2.5</a>&nbsp;&nbsp;&nbsp;<a href="#caching">Caching</a><ul><li><a href="#rfc.section.2.5.1">2.5.1</a>&nbsp;&nbsp;&nbsp;<a href="#pushing-uncacheable-content">Pushing Uncacheable Content</a></li><li><a href="#rfc.section.2.5.2">2.5.2</a>&nbsp;&nbsp;&nbsp;<a href="#pushing-stale-content">Pushing Stale Content</a></li><li><a href="#rfc.section.2.5.3">2.5.3</a>&nbsp;&nbsp;&nbsp;<a href="#pushing-with-max-age0-no-cache-and-similar">Pushing with max-age=0, no-cache and similar</a></li><li><a href="#rfc.section.2.5.4">2.5.4</a>&nbsp;&nbsp;&nbsp;<a href="#pushing-and-invalidation">Pushing and Invalidation</a></li><li><a href="#rfc.section.2.5.5">2.5.5</a>&nbsp;&nbsp;&nbsp;<a href="#pushing-and-cache-hits">Pushing and Cache Hits</a></li></ul></li><li><a href="#rfc.section.2.6">2.6</a>&nbsp;&nbsp;&nbsp;<a href="#partial-content">Partial Content</a></li><li><a href="#rfc.section.2.7">2.7</a>&nbsp;&nbsp;&nbsp;<a href="#other-pushpromise-headers">Other PUSH_PROMISE Headers</a></li><li><a href="#rfc.section.2.8">2.8</a>&nbsp;&nbsp;&nbsp;<a href="#cors">CORS</a></li><li><a href="#rfc.section.2.9">2.9</a>&nbsp;&nbsp;&nbsp;<a href="#interaction-with-http2-features">Interaction with HTTP/2 Features</a><ul><li><a href="#rfc.section.2.9.1">2.9.1</a>&nbsp;&nbsp;&nbsp;<a href="#priorities">Priorities</a></li><li><a href="#rfc.section.2.9.2">2.9.2</a>&nbsp;&nbsp;&nbsp;<a href="#connection-coalescing">Connection Coalescing</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#generating-pushpromise">Generating PUSH_PROMISE</a><ul><li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#race">Avoiding Push Races</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#using-server-push-well">Using Server Push Well</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#client-handling-of-server-push">Client Handling of Server Push</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a><ul><li><a href="#rfc.section.6.1">6.1</a>&nbsp;&nbsp;&nbsp;<a href="#pushiscached">PUSH_IS_CACHED</a></li><li><a href="#rfc.section.6.2">6.2</a>&nbsp;&nbsp;&nbsp;<a href="#pushunauthoritative">PUSH_UNAUTHORITATIVE</a></li><li><a href="#rfc.section.6.3">6.3</a>&nbsp;&nbsp;&nbsp;<a href="#pushcontentencodingnotsupported">PUSH_CONTENT_ENCODING_NOT_SUPPORTED</a></li></ul></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.8.1">8.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.8.2">8.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#algorithm-for-handling-pushes">Algorithm for Handling Pushes</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-md-8 col-md-pull-4 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">August 22, 2016</td></tr><tr><td class="text-left">Intended status: Informational</td><td class="text-right"></td></tr><tr><td class="text-left">Expires: February 23, 2017</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>Defining HTTP/2 Server Push More Carefully</h1><div class="filename">draft-nottingham-http2-pushing-00</div></div></header><hr><h2 id="rfc..abstract"><a href="#rfc..abstract">Abstract</a></h2><div class="lead"><p>This document explores the use and implementation of HTTP/2 Server Push, in order to forumlate recommendations about use and implementation.</p></div><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on February 23, 2017.</p></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2016 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></section><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> defines Server Push as a mechanism for servers to “push” request/response pairs to clients.</p></div><div id="rfc.section.1.p.2"><p>The initial use case for Server Push was saving a round trip of latency when additional content is referenced. For example, when a HTML page references CSS and JavaScript resources, the browser needs to receive the HTML response before it can fetch those resources. Server Push allows the server to proactively send them, in anticipation of the browser’s imminent need.</p></div><div id="rfc.section.1.p.3"><p>Server Push is now supported by most Web browsers, and sites are starting to experiment with it. In doing so, it’s become apparent that client handling of server push is not well-defined, leading to divergence in browser behaviour.</p></div><div id="rfc.section.1.p.4"><p>Furthermore, it appears that some deployments tend to treat Server Push like a “magic bullet”, pushing far more data that could usefully fill the idle time on the connection.</p></div><div id="rfc.section.1.p.5"><p>To improve this, this document explores how Server Push interacts with various HTTP features, with recommendations both for using Server Push in servers, and handling it by clients.</p></div><div id="rfc.section.1.p.6"><p>It’s not so much of a specification, for now, as it is a collection of ideas about how Server Push <strong>ought</strong> to work.</p></div><div id="rfc.section.1.p.7"><p>It also does not address other use cases for Server Push, such as store-and-forward or publish-and-subscribe.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div></section></section><section id="server-push-and-http-semantics"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#server-push-and-http-semantics">Server Push and HTTP Semantics</a></h2><section id="http-methods"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a href="#http-methods">HTTP Methods</a></h3><div id="rfc.section.2.1.p.1"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2 requires that promised requests be cacheable, safe, and not have a request body.</p></div><div id="rfc.section.2.1.p.2"><p>In practice, this means that GET and HEAD can be pushed. A few other methods are cacheable and safe, but since a request body is prohibited (both by the HTTP/2 spec and wire format), it’s not practical to use them.</p></div><div id="rfc.section.2.1.p.3"><p>GET operates as we’d expect; it makes a representation available as if it had been previously requested and cached, roughly.</p></div><div id="rfc.section.2.1.p.4"><p>In theory, HEAD should operate in a similar fashion; it would be as if the client had performed a HEAD and used the pushed response to update the cache, as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.3.5 (“Freshening Responses via HEAD”).</p></div><div id="rfc.section.2.1.p.5"><p>Of other status codes, perhaps the most interesting would be OPTIONS, because of its use by CORS</p></div></section><section id="http-status-codes"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a href="#http-status-codes">HTTP Status Codes</a></h3><div id="rfc.section.2.2.p.1"><p>In principle, any HTTP status code can be pushed.</p></div><div id="rfc.section.2.2.p.2"><ul><li>Informational (1xx)</li><li>Success (2xx)</li><li>Redirection (300, 301, 302, 303, 307, 308)</li><li>Not Modified (304) - see <a href="#conditional" title="Conditional Requests">Section&nbsp;2.3</a></li><li>Error (4xx and 5xx)</li></ul></div></section><section id="conditional"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a href="#conditional">Conditional Requests</a></h3><section id="pushpromise-with-if-match-if-unmodified-since"><h4 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;<a href="#pushpromise-with-if-match-if-unmodified-since">PUSH_PROMISE with If-Match / If-Unmodified-Since</a></h4><div id="rfc.section.2.3.1.p.1"><p>If the server has immediate access to the response being pushed (e.g., if the server is authoritative for it, or it is fresh in cache), it might want to send conditional headers in the <span class="tt">PUSH_PROMISE</span> request.</p></div><div id="rfc.section.2.3.1.p.2"><p>For example, a request can be sent with <span class="tt">If-Match</span> and/or <span class="tt">If-Unmodified-Since</span> to give the client the earliest possible chance to send a <span class="tt">RST_STREAM</span> on the promise, without the server starting the pushed response.</p></div><div id="rfc.figure.u.1"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/1234.jpg
Host: www.example.com
If-Match: "abcdef"
</pre></div><div id="rfc.section.2.3.1.p.3"><p>Here, when a client receives these headers in a <span class="tt">PUSH_PROMISE</span>, it can send a <span class="tt">RST_STREAM</span> if it has a fresh cached response for <span class="tt">https://www.example.com/images/1234.jpg</span> with the <span class="tt">ETag</span> “abcdef”. If it does not do so, the server will continue to push the successful (<span class="tt">2xx</span>) response (since the <span class="tt">ETag</span> does in fact match what is pushed).</p></div></section><section id="pushpromise-with-if-none-match-if-modified-since"><h4 id="rfc.section.2.3.2"><a href="#rfc.section.2.3.2">2.3.2</a>&nbsp;<a href="#pushpromise-with-if-none-match-if-modified-since">PUSH_PROMISE with If-None-Match / If-Modified-Since</a></h4><div id="rfc.section.2.3.2.p.1" class="avoidbreakafter"><p>If the server does not have a fresh local copy of the response, but does have access to a stale one (in the meaning of <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>), it can <span class="tt">PUSH_PROMISE</span> with <span class="tt">If-None-Match</span> and/or <span class="tt">If-Modified-Since</span>:</p></div><div id="rfc.figure.u.2"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/5678.jpg
Host: www.example.com
If-None-Match: "lmnop"
</pre></div><div id="rfc.section.2.3.2.p.2"><p>That way, the client again has an opportunity to send <span class="tt">RST_STREAM</span> if it already has a fresh copy in cache. Once the server has a fresh (possibly validated) response locally available, it can either push a <span class="tt">304 (Not Modified)</span> response in the case that the <span class="tt">ETag</span> hasn’t changed, and a successful (<span class="tt">2xx</span>) response if it has.</p></div><div id="rfc.section.2.3.2.p.3"><p>Note that if the client has a fresh copy in cache, but the server does not, the client here can still use the fresh copy; it has not been invalidated just because the server has not kept its copy fresh.</p></div></section><section id="generating-304-not-modified-without-a-conditional-in-pushpromise"><h4 id="rfc.section.2.3.3"><a href="#rfc.section.2.3.3">2.3.3</a>&nbsp;<a href="#generating-304-not-modified-without-a-conditional-in-pushpromise">Generating 304 (Not Modified) without a Conditional in PUSH_PROMISE</a></h4><div id="rfc.section.2.3.3.p.1"><p>If the server believes that the client does have a stale but valid copy in its cache (e.g., through the use of a cache digest; see <a href="#I-D.ietf-httpbis-cache-digest"><cite title="Cache Digests for HTTP/2">[I-D.ietf-httpbis-cache-digest]</cite></a>), it can send a <span class="tt">PUSH_PROMISE</span> followed by a pushed <span class="tt">304 (Not Modified)</span> response to revalidate that cached response, thereby making it fresh in the client’s cache.</p></div><div id="rfc.section.2.3.3.p.2"><p>If the server has a local copy of the response that it wishes to use, it can send the PUSH_PROMISE with an <span class="tt">If-None-Match</span> and/or <span class="tt">If-Modified-Since</span> conditional, as above.</p></div><div id="rfc.section.2.3.3.p.3"><p>However, if it does not, it will still be desirable to generate the <span class="tt">PUSH_PROMISE</span> as soon as possible, so as to avoid the race described in {race}.</p></div><div id="rfc.section.2.3.3.p.4" class="avoidbreakafter"><p>To allow this, a request without a conditional can be sent:</p></div><div id="rfc.figure.u.3"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/9012.jpg
Host: www.example.com
</pre></div><div id="rfc.section.2.3.3.p.5" class="avoidbreakafter"><p>When the response body is available to the server, it can send a <span class="tt">304 (Not Modified)</span> if it believes that the client already holds a copy (fresh or stale); however, it MUST include the validators to allow the client to confirm this. For example:</p></div><div id="rfc.figure.u.4"><pre>
:status: 304
ETag: "abc123"
Date: Tue, 3 Sep 2016 04:34:12 GMT
Content-Type: image/jpeg
Cache-Control: max-age=3600
</pre></div><div id="rfc.section.2.3.3.p.6"><p>In this case, if the client’s cached response does not have the same <span class="tt">ETag</span> it SHOULD re-issue the request to obtain a fresh response.</p></div><div id="rfc.section.2.3.3.p.7" class="avoidbreakafter"><p>On the other hand, if the server determines that the client does not have the appropriate cached response, it can send the full, successful (<span class="tt">2xx</span>) response:</p></div><div id="rfc.figure.u.5"><pre>
:status: 200
ETag: "abc123"
Date: Tue, 3 Sep 2016 04:34:12 GMT
Content-Type: image/jpeg
Cache-Control: max-age=3600

[ body ]
</pre></div><div id="rfc.section.2.3.3.p.8"><p><strong>EDITOR’S NOTE</strong>: This approach relies upon an <em>implicit conditional</em> in the PUSH_PROMISE request. If felt necessary, this can be made explicit, for example by defining a new conditional header <span class="tt">If-In-Digest</span>.</p></div></section></section><section id="content-negotiation"><h3 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4</a>&nbsp;<a href="#content-negotiation">Content Negotiation</a></h3><div id="rfc.section.2.4.p.1"><p>The interaction of Content Negotiation and Server Push is tricky, because it requires the server to guess what the client would have sent, in order to negotiate upon it.</p></div><div id="rfc.section.2.4.p.2"><p>However, it becomes much simpler if we assume that the client SHOULD NOT check a <span class="tt">PUSH_PROMISE</span> request’s headers to see whether or not it would have sent that request.</p></div><div id="rfc.section.2.4.p.3"><p>This means, for example, that if you <span class="tt">PUSH_PROMISE</span> the “wrong” <span class="tt">User-Agent</span>, <span class="tt">Accept-Encoding</span>, <span class="tt">User-Agent</span> or even <span class="tt">Cookie</span> header field, the client SHOULD still use the pushed response; all they’re looking for is a matching request method and URL.</p></div><div id="rfc.section.2.4.p.4" class="avoidbreakafter"><p>However, this does imply a few things:</p></div><div id="rfc.section.2.4.p.5"><ul><li>The pushed request and response MUST still “agree”; i.e., if you’re using gzip encoding, <span class="tt">Accept-Encoding</span> and <span class="tt">Content-Encoding</span> should be pushed with appropriate values.</li><li>The pushed response MUST have an appropriate <span class="tt">Vary</span> header field, if it is cacheable. This is so that the cache operates properly.</li></ul></div><div id="rfc.section.2.4.p.6"><p>Additionally, the server needs to know what the base capabilities and preferences of the client are, to allow it to select the appropriate responses to push. To aid this, we suggest that servers create a response by copying the values of the request header fields mentioned in the <span class="tt">Vary</span> response header field from the request that is identified by the <span class="tt">PUSH_PROMISE</span> frame’s Stream ID.</p></div><div id="rfc.section.2.4.p.7" class="avoidbreakafter"><p>So, for example, if the first request for a page had the following headers:</p></div><div id="rfc.figure.u.6"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /
User-Agent: FooAgent/1.0
Accept-Encoding: gzip, br
Accept-Language: en, fr
Accept: text/html,s application/example, image/*
Cookie: abc=123
</pre></div><div id="rfc.section.2.4.p.8" class="avoidbreakafter"><p>and the server wishes to push these response headers for <span class="tt">/images/123.png</span>:</p></div><div id="rfc.figure.u.7"><pre>
:status: 200
Vary: Accept-Encoding
Content-Type: image/png
Cache-Control: max-age=3600
</pre></div><div id="rfc.section.2.4.p.9" class="avoidbreakafter"><p>then it should use these headers for the <span class="tt">PUSH_PROMISE</span>:</p></div><div id="rfc.figure.u.8"><pre>
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/123.png
Accept-Encoding: gzip, br
Vary: Accept-Encoding
</pre></div></section><section id="caching"><h3 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5</a>&nbsp;<a href="#caching">Caching</a></h3><div id="rfc.section.2.5.p.1"><p>Server Push has a strong tie to HTTP caching (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>).</p></div><section id="pushing-uncacheable-content"><h4 id="rfc.section.2.5.1"><a href="#rfc.section.2.5.1">2.5.1</a>&nbsp;<a href="#pushing-uncacheable-content">Pushing Uncacheable Content</a></h4><div id="rfc.section.2.5.1.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2 says:</p></div><div id="rfc.section.2.5.1.p.2"><ul class="empty"><li>Pushed responses that are not cacheable MUST NOT be stored by any HTTP cache. They MAY be made available to the application separately.</li></ul></div></section><section id="pushing-stale-content"><h4 id="rfc.section.2.5.2"><a href="#rfc.section.2.5.2">2.5.2</a>&nbsp;<a href="#pushing-stale-content">Pushing Stale Content</a></h4></section><section id="pushing-with-max-age0-no-cache-and-similar"><h4 id="rfc.section.2.5.3"><a href="#rfc.section.2.5.3">2.5.3</a>&nbsp;<a href="#pushing-with-max-age0-no-cache-and-similar">Pushing with max-age=0, no-cache and similar</a></h4><div id="rfc.section.2.5.3.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2 says:</p></div><div id="rfc.section.2.5.3.p.2"><ul class="empty"><li>Pushed responses are considered successfully validated on the origin server (e.g., if the “no-cache” cache response directive is present (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 5.2.2)) while the stream identified by the promised stream ID is still open.</li></ul></div></section><section id="pushing-and-invalidation"><h4 id="rfc.section.2.5.4"><a href="#rfc.section.2.5.4">2.5.4</a>&nbsp;<a href="#pushing-and-invalidation">Pushing and Invalidation</a></h4></section><section id="pushing-and-cache-hits"><h4 id="rfc.section.2.5.5"><a href="#rfc.section.2.5.5">2.5.5</a>&nbsp;<a href="#pushing-and-cache-hits">Pushing and Cache Hits</a></h4><div id="rfc.section.2.5.5.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2.2 says:</p></div><div id="rfc.section.2.5.5.p.2"><ul class="empty"><li>Once a client receives a PUSH_PROMISE frame and chooses to accept the pushed response, the client SHOULD NOT issue any requests for the promised response until after the promised stream has closed. If the client determines, for any reason, that it does not wish to receive the pushed response from the server or if the server takes too long to begin sending the promised response, the client can send a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code and referencing the pushed stream’s identifier.</li></ul></div></section></section><section id="partial-content"><h3 id="rfc.section.2.6"><a href="#rfc.section.2.6">2.6</a>&nbsp;<a href="#partial-content">Partial Content</a></h3><div id="rfc.section.2.6.p.1"><p>Most use cases for pushing partial content (<a href="#RFC7233"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[RFC7233]</cite></a>) seem to</p></div></section><section id="other-pushpromise-headers"><h3 id="rfc.section.2.7"><a href="#rfc.section.2.7">2.7</a>&nbsp;<a href="#other-pushpromise-headers">Other PUSH_PROMISE Headers</a></h3><div id="rfc.section.2.7.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2.1 says:</p></div><div id="rfc.section.2.7.p.2"><ul class="empty"><li>If a client receives a PUSH_PROMISE that does not include a complete and valid set of header fields or the :method pseudo-header field identifies a method that is not safe, it MUST respond with a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</li></ul></div><div id="rfc.section.2.7.p.3"><ul><li>host</li><li>user agent</li><li>cookies</li></ul></div></section><section id="cors"><h3 id="rfc.section.2.8"><a href="#rfc.section.2.8">2.8</a>&nbsp;<a href="#cors">CORS</a></h3><div id="rfc.section.2.8.p.1"><p><a href="#WHATWG.fetch"><cite title="Fetch">[WHATWG.fetch]</cite></a></p></div></section><section id="interaction-with-http2-features"><h3 id="rfc.section.2.9"><a href="#rfc.section.2.9">2.9</a>&nbsp;<a href="#interaction-with-http2-features">Interaction with HTTP/2 Features</a></h3><section id="priorities"><h4 id="rfc.section.2.9.1"><a href="#rfc.section.2.9.1">2.9.1</a>&nbsp;<a href="#priorities">Priorities</a></h4><div id="rfc.section.2.9.1.p.1"><ul><li>incoming request effects - cancel? deprioritise others?</li></ul></div></section><section id="connection-coalescing"><h4 id="rfc.section.2.9.2"><a href="#rfc.section.2.9.2">2.9.2</a>&nbsp;<a href="#connection-coalescing">Connection Coalescing</a></h4><div id="rfc.section.2.9.2.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2 says:</p></div><div id="rfc.section.2.9.2.p.2"><ul class="empty"><li>The server MUST include a value in the :authority pseudo-header field for which the server is authoritative (see Section 10.1). A client MUST treat a PUSH_PROMISE for which the server is not authoritative as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</li></ul></div></section></section></section><section id="generating-pushpromise"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#generating-pushpromise">Generating PUSH_PROMISE</a></h2><div id="rfc.section.3.p.1"><ul><li>trickle push</li><li>relative priority</li></ul></div><section id="race"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a href="#race">Avoiding Push Races</a></h3><div id="rfc.section.3.1.p.1" class="avoidbreakafter"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 8.2.1 says:</p></div><div id="rfc.section.3.1.p.2"><ul class="empty"><li>The server SHOULD send PUSH_PROMISE (Section 6.6) frames prior to sending any frames that reference the promised responses. This avoids a race where clients issue requests prior to receiving any PUSH_PROMISE frames.</li></ul></div></section></section><section id="using-server-push-well"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#using-server-push-well">Using Server Push Well</a></h2><div id="rfc.section.4.p.1"><ul><li>not magic</li><li>best practices for content re pushing too much</li><li>long wait (server think, back end)</li></ul></div></section><section id="client-handling-of-server-push"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#client-handling-of-server-push">Client Handling of Server Push</a></h2><div id="rfc.section.5.p.1"><ul><li>matching push_promise headers</li><li>affinity of push – load group (FF), navigation handle (Edge)</li><li>canonicalisation when receiving</li><li>push telemetry</li><li>error codes</li><li>clients rejecting pushes</li><li>visualising with devtools</li><li>pushing content of next page</li><li>push api in browsers?</li><li>dependencies?</li><li>client behaviour when push is cancelled</li><li>push direct into cache</li><li>preload</li><li>link @rel as=’’</li><li>“we don’t want you to put anything into the cache that the user has not explicitly accessed”</li><li>constructing push URIs (fragment, headers needed, allowed, disallowed?)</li></ul></div></section><section id="iana-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.6.p.1" class="avoidbreakafter"><p>This document registers the following entries in the HTTP/2 Error Code registry:</p></div><section id="pushiscached"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a>&nbsp;<a href="#pushiscached">PUSH_IS_CACHED</a></h3><div id="rfc.section.6.1.p.1"><ul><li>Name: PUSH_IS_CACHED</li><li>Code: 0xNN</li><li>Description: On a RST_STREAM sent on a pushed stream, indicates that the sender already had a fresh cached response, and did not need to update it.</li><li>Specification: [this document]</li></ul></div></section><section id="pushunauthoritative"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a>&nbsp;<a href="#pushunauthoritative">PUSH_UNAUTHORITATIVE</a></h3><div id="rfc.section.6.2.p.1"><ul><li>Name: PUSH_UNAUTHORITATIVE</li><li>Code: 0xNN</li><li>Description: On a RST_STREAM sent on a pushed stream, indicates that the server is not considered authoritative for the origin of the pushed request.</li><li>Specification: [this document]</li></ul></div></section><section id="pushcontentencodingnotsupported"><h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3</a>&nbsp;<a href="#pushcontentencodingnotsupported">PUSH_CONTENT_ENCODING_NOT_SUPPORTED</a></h3><div id="rfc.section.6.3.p.1"><ul><li>Name: PUSH_CONTENT_ENCODING_NOT_SUPPORTED</li><li>Code: 0xNN</li><li>Description: On a RST_STREAM sent on a pushed stream, indicates that the content-coding of the response is not supported by the client.</li><li>Specification: [this document]</li></ul></div></section></section><section id="security-considerations"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2></section><section id="rfc.references"><h2 id="rfc.section.8"><a href="#rfc.section.8">8.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1</a> Normative References</h3><dl class="dl-horizontal"><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC7233">[RFC7233]</dt><dd>Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7233">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a>”, RFC&nbsp;7233, <a href="http://dx.doi.org/10.17487/RFC7233">DOI&nbsp;10.17487/RFC7233</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7233">http://www.rfc-editor.org/info/rfc7233</a>&gt;.</dd><dt id="RFC7234">[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC&nbsp;7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI&nbsp;10.17487/RFC7234</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7234">http://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC&nbsp;7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI&nbsp;10.17487/RFC7540</a>, May&nbsp;2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2</a> Informative References</h3><dl class="dl-horizontal"><dt id="I-D.ietf-httpbis-cache-digest">[I-D.ietf-httpbis-cache-digest]</dt><dd>Oku, K. and M. Nottingham, “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-cache-digest-00">Cache Digests for HTTP/2</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-cache-digest-00 (work in progress), July&nbsp;2016.</dd><dt id="WHATWG.fetch">[WHATWG.fetch]</dt><dd>WHAT Working Group, “<a href="https://fetch.spec.whatwg.org/">Fetch</a>”, 2016, &lt;<a href="https://fetch.spec.whatwg.org/">https://fetch.spec.whatwg.org/</a>&gt;.</dd></dl></section></section><section id="algorithm-for-handling-pushes"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#algorithm-for-handling-pushes">Algorithm for Handling Pushes</a></h2><div id="rfc.section.A.p.1" class="avoidbreakafter"><p>Upon receiving a PUSH_PROMISE frame on a connection, possibly followed by an number of CONTINUATION frames, the last with END_HEADERS set:</p></div><div id="rfc.section.A.p.2"><ol><li>If the <span class="tt">Stream Identifier</span> of the PUSH_PROMISE does not refer to a stream that is open,</li><li>If the <span class="tt">Promised Stream ID</span> refers to a stream that is open, or has an odd number,</li><li>Parse the Header Block into a set of header fields <span class="tt">headers</span>.</li><li>If the <span class="tt">:method</span> header field’s value is not <span class="tt">GET</span> or <span class="tt">HEAD</span>,</li><li></li></ol></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Author's Address</a></h2><p><b>Mark Nottingham</b><br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></p></section></div></div></div><script src="../Tools/bower_components/jquery/dist/jquery.min.js"></script><script src="../Tools/bower_components/bootstrap/dist/js/bootstrap.min.js"></script></body></html>