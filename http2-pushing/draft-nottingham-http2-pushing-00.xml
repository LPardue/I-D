<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfc2629xslt/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-http2-pushing-00" category="info">

  <front>
    <title abbrev="HTTP/2 Pushing">Defining HTTP/2 Server Push More Carefully</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization></organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2016"/>

    <area>General</area>
    
    <keyword>push</keyword>

    <abstract>


<t>This document explores the use and implementation of HTTP/2 Server Push, in order to forumlate
recommendations about use and implementation.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP/2 <xref target="RFC7540"/> defines Server Push as a mechanism for servers to “push” request/response pairs
to clients.</t>

<t>The initial use case for Server Push was saving a round trip of latency when additional content is
referenced. For example, when a HTML page references CSS and JavaScript resources, the browser
needs to receive the HTML response before it can fetch those resources. Server Push allows the
server to proactively send them, in anticipation of the browser’s imminent need.</t>

<t>Server Push is now supported by most Web browsers, and sites are starting to experiment with it. In
doing so, it’s become apparent that client handling of server push is not well-defined, leading to
divergence in browser behaviour.</t>

<t>Furthermore, it appears that some deployments tend to treat Server Push like a “magic bullet”,
pushing far more data that could usefully fill the idle time on the connection.</t>

<t>To improve this, this document explores how Server Push interacts with various HTTP features, with
recommendations both for using Server Push in servers, and handling it by clients.</t>

<t>It’s not so much of a specification, for now, as it is a collection of ideas about how Server Push
<spanx style="strong">ought</spanx> to work.</t>

<t>It also does not address other use cases for Server Push, such as store-and-forward or
publish-and-subscribe.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in
<xref target="RFC2119"/>.</t>

</section>
</section>
<section anchor="server-push-and-http-semantics" title="Server Push and HTTP Semantics">

<section anchor="http-methods" title="HTTP Methods">

<t><xref target="RFC7540"/>, Section 8.2 requires that promised requests be cacheable, safe, and not have a request
body.</t>

<t>In practice, this means that GET and HEAD can be pushed. A few other methods are cacheable and
safe, but since a request body is prohibited (both by the HTTP/2 spec and wire format), it’s not
practical to use them.</t>

<t>GET operates as we’d expect; it makes a representation available as if it had been previously
requested and cached, roughly.</t>

<t>In theory, HEAD should operate in a similar fashion; it would be as if the client had performed a
HEAD and used the pushed response to update the cache, as per <xref target="RFC7234"/>, Section 4.3.5
(“Freshening Responses via HEAD”). This might be useful, for example, to update the metadata of
that response. However, the same effect can also be achieved by using a conditional request; see
<xref target="conditional"/>.</t>

<t>Of other status codes, perhaps the most interesting would be OPTIONS, because of its use by CORS
(<xref target="WHATWG.fetch"/>). See <xref target="cors"/>.</t>

</section>
<section anchor="http-status-codes" title="HTTP Status Codes">

<t>In principle, any HTTP status code can be pushed in a response. Success (2xx), redirection (300,
301, 302, 303, 307, 308) and eror (4xx and 5xx) status codes all have the same caching semantics,
described in <xref target="RFC7234"/>.</t>

<t>This implies that if they are pushed to the client, any of these status codes should behave as if
the client had requested them previously and stored the response. For example, a 403 (Forbidden)
can be pushed and stored just as a 200 (OK) – even if this would be of very limited use.</t>

<t>There are a few complications to consider, however.</t>

<t><list style="symbols">
  <t>304 (Not Modified) has special interaction with caches and validation that is described in 
<xref target="conditional"/>.</t>
  <t>Other 3xx Redirection codes indicate, when pushed, that if the client were to make that request,
it will be redirected. That does not mean that the <spanx style="verb">Location</spanx> header’s URL should be followed
immediately; it is only upon an actual request from the client that it should be acted upon.
Therefore, the caching semantics of 3xx redirects take effect.</t>
  <t>1xx Informational codes don’t make much sense as a Push payload, because the headers they convey
are lost in most implementations (to be subsumed by the headers in the final response). For
example, the headers on a 100 (Continue) response are a no-op; effectively, it’s a one-bit “go
ahead” signal. Since HTTP/2 already has protocol-level signalling mechanisms, it’s probably best
to say that 1xx responses SHOULD NOT be sent in Server Push, and MUST be ignored when received.</t>
  <t>401 (Unauthenticated) and 407 (Proxy-Authenticate) are covered in <xref target="auth"/>.</t>
  <t>Many other 4xx and 5xx status codes don’t have any practical use in Server Push; e.g., 405
(Method Not Allowed), 408 (Request Timeout), 411 (Length Required) and 414 (URI Too Long) are all
reactions to problems with the request. Since the server has sent that request, their use is
somewhat self-defeating; however, this does not mean that a client encountering them should
generate an error, or fail to use the response. At the very least, if the response is available
in devtools, debugging will be easier; additionally, someone might find a creative, appropriate
use for them some day.</t>
</list></t>

</section>
<section anchor="conditional" title="Conditional Requests">

<section anchor="if-match-if-unmodified-since" title="If-Match / If-Unmodified-Since">

<t>If the server has immediate access to the response being pushed (e.g., if the server is authoritative for it, or it is fresh in cache), it might want to send conditional headers in the <spanx style="verb">PUSH_PROMISE</spanx> request.</t>

<t>For example, a request can be sent with <spanx style="verb">If-Match</spanx> and/or <spanx style="verb">If-Unmodified-Since</spanx> to give the client
the earliest possible chance to send a <spanx style="verb">RST_STREAM</spanx> on the promise, without the server starting the
pushed response.</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/1234.jpg
Host: www.example.com
If-Match: "abcdef"
]]></artwork></figure>

<t>Here, when a client receives these headers in a <spanx style="verb">PUSH_PROMISE</spanx>, it can send a <spanx style="verb">RST_STREAM</spanx> if it
has a fresh cached response for <spanx style="verb">https://www.example.com/images/1234.jpg</spanx> with the <spanx style="verb">ETag</spanx> “abcdef”.
If it does not do so, the server will continue to push the successful (<spanx style="verb">2xx</spanx>) response (since the
<spanx style="verb">ETag</spanx> does in fact match what is pushed).</t>

</section>
<section anchor="if-none-match-if-modified-since" title="If-None-Match / If-Modified-Since">

<t>If the server does not have a fresh local copy of the response, but does have access to a stale one
(in the meaning of <xref target="RFC7234"/>), it can <spanx style="verb">PUSH_PROMISE</spanx> with <spanx style="verb">If-None-Match</spanx> and/or
<spanx style="verb">If-Modified-Since</spanx>:</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/5678.jpg
Host: www.example.com
If-None-Match: "lmnop"
]]></artwork></figure>

<t>That way, the client again has an opportunity to send <spanx style="verb">RST_STREAM</spanx> if it already has a fresh copy
in cache.</t>

<t>Once the server has obtained a fresh (possibly validated) response, it can either push a <spanx style="verb">304 (Not
Modified)</spanx> response in the case that the <spanx style="verb">ETag</spanx> hasn’t changed, or a successful (<spanx style="verb">2xx</spanx>) response if
it has.</t>

<t>Note that if the client has a fresh copy in cache, but the server does not, the client can still
use the fresh copy; it has not been invalidated just because the server has not kept its copy fresh.</t>

</section>
<section anchor="not-modified-without-a-conditional" title="304 (Not Modified) without a Conditional">

<t>If the server believes that the client does have a stale but valid copy in its cache (e.g., through
the use of a cache digest; see <xref target="I-D.ietf-httpbis-cache-digest"/>), it can send a <spanx style="verb">PUSH_PROMISE</spanx>
followed by a pushed <spanx style="verb">304 (Not Modified)</spanx> response to revalidate that cached response, thereby
making it fresh in the client’s cache.</t>

<t>If the server has a local copy of the response that it wishes to use, it can send the PUSH_PROMISE
with an <spanx style="verb">If-None-Match</spanx> and/or <spanx style="verb">If-Modified-Since</spanx> conditional, as above.</t>

<t>However, if it does not, it will still be desirable to generate the <spanx style="verb">PUSH_PROMISE</spanx> as soon as
possible, so as to avoid the race described in {race}.</t>

<t>To allow this, a request without a conditional can be sent:</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/9012.jpg
Host: www.example.com
]]></artwork></figure>

<t>When the response body is available to the server, it can send a <spanx style="verb">304 (Not Modified)</spanx> if it
believes that the client already holds a copy (fresh or stale); however, it MUST include the
validators to allow the client to confirm this. For example:</t>

<figure><artwork><![CDATA[
:status: 304
ETag: "abc123"
Date: Tue, 3 Sep 2016 04:34:12 GMT
Content-Type: image/jpeg
Cache-Control: max-age=3600
]]></artwork></figure>

<t>In this case, if the client’s cached response does not have the same <spanx style="verb">ETag</spanx> it SHOULD re-issue the
request to obtain a fresh response.</t>

<t>On the other hand, if the server determines that the client does not have the appropriate cached response, it can send the full, successful (<spanx style="verb">2xx</spanx>) response:</t>

<figure><artwork><![CDATA[
:status: 200
ETag: "abc123"
Date: Tue, 3 Sep 2016 04:34:12 GMT
Content-Type: image/jpeg
Cache-Control: max-age=3600

[ body ]
]]></artwork></figure>

<t><spanx style="strong">EDITOR’S NOTE</spanx>: This approach relies upon an <spanx style="emph">implicit conditional</spanx> in the PUSH_PROMISE request.
If felt necessary, this can be made explicit, for example by defining a new conditional header
<spanx style="verb">If-In-Digest</spanx>.</t>

</section>
</section>
<section anchor="content-negotiation" title="Content Negotiation">

<t>The interaction of Content Negotiation and Server Push is tricky, because it requires the server to
guess what the client would have sent, in order to negotiate upon it.</t>

<t>However, it becomes much simpler if we assume that the client SHOULD NOT check a <spanx style="verb">PUSH_PROMISE</spanx> request’s headers to see whether or not it would have sent that request.</t>

<t>This means, for example, that if you <spanx style="verb">PUSH_PROMISE</spanx> the “wrong” <spanx style="verb">User-Agent</spanx>, <spanx style="verb">Accept-Encoding</spanx>,
<spanx style="verb">User-Agent</spanx> or even <spanx style="verb">Cookie</spanx> header field, the client SHOULD still use the pushed response; all
they’re looking for is a matching request method and URL.</t>

<t>However, this does imply a few things:</t>

<t><list style="symbols">
  <t>The pushed request and response MUST still “agree”; i.e., if you’re using gzip encoding, <spanx style="verb">Accept-Encoding</spanx> and <spanx style="verb">Content-Encoding</spanx> should be pushed with appropriate values.</t>
  <t>The pushed response MUST have an appropriate <spanx style="verb">Vary</spanx> header field, if it is cacheable. This is so that the cache operates properly.</t>
</list></t>

<t>Additionally, the server needs to know what the base capabilities and preferences of the client
are, to allow it to select the appropriate responses to push. To aid this, we suggest that servers
create a response by copying the values of the request header fields mentioned in the <spanx style="verb">Vary</spanx>
response header field from the request that is identified by the <spanx style="verb">PUSH_PROMISE</spanx> frame’s Stream ID.</t>

<t>So, for example, if the first request for a page had the following headers:</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /
User-Agent: FooAgent/1.0
Accept-Encoding: gzip, br
Accept-Language: en, fr
Accept: text/html,s application/example, image/*
Cookie: abc=123
]]></artwork></figure>

<t>and the server wishes to push these response headers for <spanx style="verb">/images/123.png</spanx>:</t>

<figure><artwork><![CDATA[
:status: 200
Vary: Accept-Encoding
Content-Type: image/png
Cache-Control: max-age=3600
]]></artwork></figure>

<t>then it should use these headers for the <spanx style="verb">PUSH_PROMISE</spanx>:</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/123.png
Accept-Encoding: gzip, br
Vary: Accept-Encoding
]]></artwork></figure>

</section>
<section anchor="caching" title="Caching">

<t>Server Push has a strong tie to HTTP caching (<xref target="RFC7234"/>).</t>

<section anchor="scope" title="Caching and Scope of Server Push">

</section>
<section anchor="pushing-uncacheable-content" title="Pushing Uncacheable Content">

<t><xref target="RFC7540"/>, Section 8.2 says:</t>

<t><list style='empty'>
  <t>Pushed responses that are not cacheable MUST NOT be stored by any HTTP cache. They MAY be made
available to the application separately.</t>
</list></t>

<t>As a result, any response that cannot be stored as per the rules in <xref target="RFC7234"/>, Section 3 cannot
be stored by a receiving cache.</t>

<t>However, they might still be usable if a browser API for Server Push emerges. See
<eref target="https://github.com/whatwg/fetch/issues/51">https://github.com/whatwg/fetch/issues/51</eref>.</t>

<t>It’s less clear if they can be used to trigger other actions after being temporarily stored. For
example, it might be useful to store an uncacheable 302 redirect for the duration of the
connection, so that a reference, when found, will be redirected without delay.</t>

<t>The same effect could be achieved by merely sending <spanx style="verb">Cache-Control: max-age=0</spanx> (as per below), but
it’s questionable as to whether this would surprise Web developers.</t>

</section>
<section anchor="pushing-stale-content" title="Pushing Stale Content">

<t>becoming stale too</t>

</section>
<section anchor="pushing-with-max-age0-no-cache" title="Pushing with max-age=0, no-cache">

<t><xref target="RFC7540"/>, Section 8.2 says:</t>

<t><list style='empty'>
  <t>Pushed responses are considered successfully validated on the origin server (e.g., if the “no-cache” cache response directive is present (<xref target="RFC7234"/>, Section 5.2.2)) while the stream identified by the promised stream ID is still open.</t>
</list></t>

<t>This implies that, while that stream is open, the pushed response can be considered fresh, even when it contains any (or all) of the following cache directives:</t>

<t><list style="symbols">
  <t>max-age=0</t>
  <t>no-cache</t>
  <t>s-maxage=0 (for shared caches)</t>
</list></t>

<t>This applies to <spanx style="verb">Expires</spanx> when the value matches that of the <spanx style="verb">Date</spanx> header.</t>

<t>See <xref target="scope"/> for a discussion of how widely such a response should be made available.</t>

</section>
<section anchor="pushing-and-invalidation" title="Pushing and Invalidation">

</section>
<section anchor="pushing-and-cache-hits" title="Pushing and Cache Hits">

<t><xref target="RFC7540"/>, Section 8.2.2 says:</t>

<t><list style='empty'>
  <t>Once a client receives a PUSH_PROMISE frame and chooses to accept the pushed response, the client SHOULD NOT issue any requests for the promised response until after the promised stream has closed.
If the client determines, for any reason, that it does not wish to receive the pushed response from the server or if the server takes too long to begin sending the promised response, the client can send a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code and referencing the pushed stream’s identifier.</t>
</list></t>

</section>
</section>
<section anchor="partial-content" title="Partial Content">

<t>Most use cases for pushing partial content (<xref target="RFC7233"/>) seem to</t>

</section>
<section anchor="auth" title="Authentication">

<t>401 (Unauthorized) has the side effect of prompting the user for their credentials. Again, this
does not mean that the User Agent ought to do so when receiving a pushed 401; rather, this could be
seen as a mechanism to avoid the round trip that would otherwise be required – just as in other
intended uses of Server Push.</t>

<t>Presumably, the PUSH_PROMISE for such a request would omit the <spanx style="verb">Authentication</spanx> header field.</t>

<t>407 (Proxy Authenticate) is probably best not to push, since it’s confusing authority of the
network vs. the origin. Clients SHOULD ignore such pushes.</t>

</section>
<section anchor="other-pushpromise-headers" title="Other PUSH_PROMISE Headers">

<t><xref target="RFC7540"/>, Section 8.2.1 says:</t>

<t><list style='empty'>
  <t>If a client receives a PUSH_PROMISE that does not include a complete and valid set of header fields or the :method pseudo-header field identifies a method that is not safe, it MUST respond with a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</t>
</list></t>

<t><list style="symbols">
  <t>host</t>
  <t>user agent</t>
  <t>cookies</t>
</list></t>

</section>
<section anchor="cors" title="CORS">

<t><xref target="WHATWG.fetch"/></t>

</section>
<section anchor="interaction-with-http2-features" title="Interaction with HTTP/2 Features">

<section anchor="priorities" title="Priorities">

<t><list style="symbols">
  <t>incoming request effects - cancel? deprioritise others?</t>
</list></t>

</section>
<section anchor="connection-coalescing" title="Connection Coalescing">

<t><xref target="RFC7540"/>, Section 8.2 says:</t>

<t><list style='empty'>
  <t>The server MUST include a value in the :authority pseudo-header field for which the server is authoritative (see Section 10.1). A client MUST treat a PUSH_PROMISE for which the server is not authoritative as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</t>
</list></t>

</section>
</section>
</section>
<section anchor="generating-pushpromise" title="Generating PUSH_PROMISE">

<t><list style="symbols">
  <t>trickle push</t>
  <t>relative priority</t>
</list></t>

<section anchor="race" title="Avoiding Push Races">

<t><xref target="RFC7540"/>, Section 8.2.1 says:</t>

<t><list style='empty'>
  <t>The server SHOULD send PUSH_PROMISE (Section 6.6) frames prior to sending any frames that reference the promised responses. This avoids a race where clients issue requests prior to receiving any PUSH_PROMISE frames.</t>
</list></t>

</section>
</section>
<section anchor="using-server-push-well" title="Using Server Push Well">

<t><list style="symbols">
  <t>not magic</t>
  <t>best practices for content re pushing too much</t>
  <t>long wait (server think, back end)</t>
</list></t>

</section>
<section anchor="client-handling-of-server-push" title="Client Handling of Server Push">

<t><list style="symbols">
  <t>matching push_promise headers</t>
  <t>affinity of push – load group (FF), navigation handle (Edge)</t>
  <t>canonicalisation when receiving</t>
  <t>push telemetry</t>
  <t>error codes</t>
  <t>clients rejecting pushes</t>
  <t>visualising with devtools</t>
  <t>pushing content of next page</t>
  <t>push api in browsers?</t>
  <t>dependencies?</t>
  <t>client behaviour when push is cancelled</t>
  <t>push direct into cache</t>
  <t>preload</t>
  <t>link @rel as=’’</t>
  <t>“we don’t want you to put anything into the cache that the user has not explicitly accessed”</t>
  <t>constructing push URIs (fragment, headers needed, allowed, disallowed?)</t>
</list></t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document registers the following entries in the HTTP/2 Error Code registry:</t>

<section anchor="pushiscached" title="PUSH_IS_CACHED">

<t><list style="symbols">
  <t>Name: PUSH_IS_CACHED</t>
  <t>Code: 0xNN</t>
  <t>Description: On a RST_STREAM sent on a pushed stream, indicates that the sender already had a fresh cached response, and did not need to update it.</t>
  <t>Specification: [this document]</t>
</list></t>

</section>
<section anchor="pushunauthoritative" title="PUSH_UNAUTHORITATIVE">

<t><list style="symbols">
  <t>Name: PUSH_UNAUTHORITATIVE</t>
  <t>Code: 0xNN</t>
  <t>Description: On a RST_STREAM sent on a pushed stream, indicates that the server is not considered authoritative for the origin of the pushed request.</t>
  <t>Specification: [this document]</t>
</list></t>

</section>
<section anchor="pushcontentencodingnotsupported" title="PUSH_CONTENT_ENCODING_NOT_SUPPORTED">

<t><list style="symbols">
  <t>Name: PUSH_CONTENT_ENCODING_NOT_SUPPORTED</t>
  <t>Code: 0xNN</t>
  <t>Description: On a RST_STREAM sent on a pushed stream, indicates that the content-coding of the response is not supported by the client.</t>
  <t>Specification: [this document]</t>
</list></t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC7540' target='http://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor='RFC7234' target='http://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor='RFC7233' target='http://www.rfc-editor.org/info/rfc7233'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='Y.' surname='Lafon' fullname='Y. Lafon' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems.  This document defines range requests and the rules for constructing and combining responses to those requests.</t></abstract>
</front>
<seriesInfo name='RFC' value='7233'/>
<seriesInfo name='DOI' value='10.17487/RFC7233'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="WHATWG.fetch" target="https://fetch.spec.whatwg.org/">
  <front>
    <title>Fetch</title>
    <author >
      <organization>WHAT Working Group</organization>
    </author>
    <date year="2016"/>
  </front>
</reference>




<reference anchor='I-D.ietf-httpbis-cache-digest'>
<front>
<title>Cache Digests for HTTP/2</title>

<author initials='K' surname='Oku' fullname='Kazuho Oku'>
    <organization />
</author>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<date month='July' day='8' year='2016' />

<abstract><t>This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache's contents.  Servers can then use this to inform their choices of what to push to clients.  Note to Readers  Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at https://lists.w3.org/Archives/Public/ietf-http-wg/ .  Working Group information can be found at http://httpwg.github.io/ ; source code and issues list for this draft can be found at https://github.com/httpwg/http-extensions/labels/cache-digest .</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-cache-digest-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-cache-digest-00.txt' />
</reference>




    </references>




  </back>
</rfc>

