<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.22 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-http-encryption-encoding-01" category="info">

  <front>
    <title abbrev="HTTP encryption coding">Encrypted Content-Encoding for HTTP</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization></organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>http://www.mnot.net/</uri>
      </address>
    </author>
    <author initials="M." surname="Thomson" fullname="Martin Thomson">
      <organization>Mozilla</organization>
      <address>
        <email>martin.thomson@gmail.com</email>
      </address>
    </author>

    <date year="2015"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This memo introduces a content-coding for HTTP that allows message payloads to be encrypted.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>It is sometimes desirable to encrypt the contents of a HTTP message (request or response) in a
persistent manner, so that when their payload is stored (e.g., with a HTTP PUT), only someone with
the appropriate key can read it.</t>

<t>For example, it might be necessary to store a file on a server without exposing its contents to
that server. Furthermore, that same file could be replicated to other servers (to make it more
resistant to server or network failure), downloaded by clients (to make it available offline), etc.
without exposing its contents.</t>

<t>These uses are not met by the use of TLS <xref target="RFC5246"></xref>, since it only encrypts the channel between the
client and server.</t>

<t>This document specifies a content-coding <xref target="RFC7231"></xref>) for HTTP to serve these and other use cases.</t>

<t>This mechanism is likely only a small part of a larger design that uses content encryption.  In
particular, this document does not describe key management practices.  How clients and servers
acquire and identify keys will depend on the use case.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in
<xref target="RFC2119"></xref>.</t>

</section>
</section>
<section anchor="aesgcm128" title="The “aesgcm-128” HTTP content-coding">

<t>The “aesgcm-128” HTTP content-coding indicates that a payload has been encrypted using Advanced
Encryption Standard (AES) in Galois/Counter Mode (GCM) <xref target="NIST80038D">AES</xref>, using a 128 bit
content encryption key.</t>

<t>When this content-coding is in use, the Encryption header field <xref target="encryption"/> MUST be present, and
MUST include sufficient information to determine the content encryption key (see <xref target="derivation"/>).</t>

<t>The “aesgcm-128” content-coding uses a fixed block size for any given payload.  Each block is
followed by 128-bit authentication tag.  The block size defaults to 4096 octets, but can be changed
using the “bs” parameter on the Encryption header field.  This block size is not to be mistaken for
the block size of the cipher.</t>

<t>The encrypted content is therefore an sequence of blocks, each with a length equal to the value of
the “bs” parameter, and 16 octets of authentication tag.</t>

<figure><artwork><![CDATA[
+-------------------------------+-----------------+
| Encrypted Content (bs octets) | Tag (16 octets) |
+-------------------------------+-----------------+
]]></artwork></figure>

<t>The final block can be any size up to the block size.  AES-GCM does not require padding of
plaintext, so the size of the final encrypted block can be determined by subtracting the 16 bytes of
authentication tag from the remaining bytes.</t>

<t>Each block contains between 0 and 255 bytes of padding, inserted into a block before the enciphered
content.  The length of the padding is stored in the first byte of the payload.  All padding bytes
MUST be set to zero.  It is a fatal decryption error to have a block with more padding than the
block size.</t>

<t>The initialization vector for each block is a 96-bit value containing the index of the current
block.  Blocks are indexed starting at zero.</t>

<t>The additional data passed to the AES-GCM algorithm consists of the concatenation of:</t>

<t><list style="numbers">
  <t>the ASCII-encoded string “Content-Encoding: aesgcm-128”,</t>
  <t>a zero octet, and</t>
  <t>the index of the current block encoded as a 64-bit unsigned integer.</t>
</list></t>

</section>
<section anchor="encryption" title="The “Encryption” HTTP header field">

<t>The “Encryption” HTTP header field describes the encrypted content encoding(s) that have been
applied to a message payload, and therefore how those content encoding(s) can be removed.</t>

<figure><artwork><![CDATA[
  Encryption-val = #cipher_params
  cipher_params = [ param *( ";" param ) ]
]]></artwork></figure>

<t>If the payload is encrypted more than once (as reflected by having multiple content-codings that
imply encryption), each cipher is reflected in the Encryption header field, in the order in which
they were applied.</t>

<t>The Encryption header MAY be omitted if the sender does not intend for the immediate recipient to
be able to decrypt the message.  Alternatively, the Encryption header field MAY be omitted if the
sender intends for the recipient to acquire the header field by other means.</t>

<t>Servers processing PUT requests MUST persist the value of the Encryption header field, unless they
remove the content-coding by decrypting the payload.</t>

<section anchor="encryption-header-field-parameters" title="Encryption Header Field Parameters">

<t>The following parameters are used in determining the key that is used for encryption:</t>

<t><list style="hanging">
  <t hangText='key:'>
  The “key” parameter contains the URL-safe base64 <xref target="RFC4648"></xref> bytes of the key.</t>
  <t hangText='keyid:'>
  The “keyid” parameter contains a string that identifies a key.</t>
  <t hangText='ecdh:'>
  The “ecdh” parameter contains an ephemeral elliptic curve Diffie-Hellman (ECDH) share.  The point
is encoding using the URL-safe base64 encoding <xref target="RFC4648"></xref>.</t>
  <t hangText='nonce:'>
  The “nonce” parameter contains a base64 URL-encoded bytes of a nonce that is used to derive a
content encryption key.  The nonce value MUST be present, and MUST contain 128 bits of random
entropy.</t>
</list></t>

<t>These parameters are used to determine a content encryption key.  The key derivation process is
described in <xref target="derivation"/>.</t>

<t>In addition to key determination parameters, the “bs” parameter includes a positive integer value
that describes the block size.</t>

</section>
<section anchor="derivation" title="Content Encryption Key Derivation">

<t>The content encryption key used by the content-coding is determined based on the information in the
Encryption header field.  Several variations are possible:</t>

<t><list style="hanging">
  <t hangText='explicit key:'>
  The “key” parameter is decoded and used directly if present.  Other key determination parameters
can be ignored if this parameter is present.</t>
  <t hangText='identified key:'>
  The “keyid” is used to identify a key that is discovered by some out-of-band means.  A “keyid”
parameter can be omitted if a key can be identified based on other information.</t>
  <t hangText='ecdh:'>
  The ECDH share included in the “ecdh” parameter is combined with a share from the intended
recipient of the encrypted message using elliptic curve Diffie-Hellman (ECDH) <xref target="RFC4492"></xref> to determine
a shared secret.</t>
  <t>When an “ecdh” parameter is present, the “keyid” parameter identifies the key pair that the
intended recipient needs to use to recover the shared secret.  The specific curve and point format
are therefore identified by the “keyid” parameter, which identifies the key pair that the receiver
uses to decrypt the content.  Specifications that rely on this form of encryption MUST either
specify what curve and point format to use, or how a curve and point format is negotiated between
sender and receiver.</t>
</list></t>

<t>The product of each of these alternatives methods generates a sequence of octets.  This is used as
the secret input to the TLS pseudorandom function (PRF) (as defined in Section 5 of <xref target="RFC5246"></xref>)
with the SHA-256 hash function <xref target="FIPS180-2"></xref> to generate the key.</t>

<t>The label used for the PRF is the ASCII string “encrypted Content-Encoding” and the seed is the
value of the “nonce” parameter, which is first decoded.  The “nonce” parameter therefore MUST be
provided to enable decryption.</t>

</section>
</section>
<section anchor="examples" title="Examples">

<section anchor="successful-get-response" title="Successful GET Response">

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/octet-stream
Content-Encoding: aesgcm-128
Connection: close
Encryption: keyid="http://example.org/bob/keys/123";
            nonce="XZwpw6o37R-6qoZjw6KwAw"

[encrypted payload]
]]></artwork></figure>

<t>Here, a successful HTTP GET response has been encrypted using a key that is identified by a URI.</t>

<t>Note that the media type has been changed to “application/octet-stream” to avoid exposing
information about the content.</t>

</section>
<section anchor="encryption-and-compression" title="Encryption and Compression">

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: text/html
Content-Encoding: aesgcm-128, gzip
Transfer-Encoding: chunked
Encryption: keyid="mailto:me@example.com";
            nonce="m2hJ_NttRtFyUiMRPwfpHA"

[encrypted payload]
]]></artwork></figure>

</section>
<section anchor="encryption-with-more-than-one-key" title="Encryption with More Than One Key">

<figure><artwork><![CDATA[
PUT /thing HTTP/1.1
Host: storage.example.com
Content-Type: application/http
Content-Encoding: aesgcm-128, aesgcm-128
Content-Length: 1234
Encryption: keyid="mailto:me@example.com";
            ecdh="BLiZzhckgp88pANskUpCkGV7-IFLHC-aF8MMPW7i8P...";
            nonce="NfzOeuV5USPRA-n_9s1Lag",
            keyid="http://example.org/bob/keys/123";
            nonce="bDMSGoc2uobK_IhavSHsHA"

[encrypted payload]
]]></artwork></figure>

<t>Here, a PUT request has been encrypted with two keys; both will be necessary to read the content.
The inner layer of encryption uses elliptic curve Diffie-Hellman (the actual value is truncated).</t>

</section>
<section anchor="encryption-with-explicit-key" title="Encryption with Explicit Key">

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Length: 31
Content-Encoding: aesgcm-128
Encryption: key="T9jtNY-vTvq7mSVlNFJbyw";
            nonce="nJJ-xXkP5sM_8Zp00Gp-ig"

zIZwlquLit2UEsKh1eBATJadBieZUEOI9sfiJtT6DwU
]]></artwork></figure>

<t>This example shows the string “I am the walrus” being encrypted.  The content body is shown here
encoded in URL-safe base64 for presentation reasons only.</t>

</section>
<section anchor="diffie-hellman-encryption" title="Diffie-Hellman Encryption">

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Length: 31
Content-Encoding: aesgcm-128
Encryption: keyid="theKey";
            nonce="6hCMStcuoSdfvDjpm0qhdQ";
            ecdh="BOsUGWuTKnbckPjtsU-vCi1BQaQu5B9iEoP8No2B34r
                  SRvaA_er_d2tpRy-3e-a6n5W7MIPBcacIJ7eDWkvnDxI"

fDBJbV-a2XnWwcJQTpDinRoDqOHdmH5XxJD0Gob7wEg
]]></artwork></figure>

<t>This example shows the same string, “I am the walrus”, encrypted using ECDH over the P-256 curve
<xref target="FIPS186"></xref>.  The receiver (in this case, the HTTP client) uses the key identified by the string
“theKey” and the sender (the server) uses a key pair for which the public share is included in the
“ecdh” parameter above.  All keys are shown using uncompressed points <xref target="X.692"></xref> encoded using URL-safe
base64.  Line wrapping is added for presentation purposes only.</t>

<figure><artwork><![CDATA[
Receiver:
  private key: iG9ObZuRssarFIh859KjDpysTMybv4HNoZoPc-1DzWo
  public key: BOsUGWuTKnbckPjtsU-vCi1BQaQu5B9iEoP8No2B34rS
              RvaA_er_d2tpRy-3e-a6n5W7MIPBcacIJ7eDWkvnDxI
Sender:
  private key: XKtP2DkzcIe5IP-F2aQEGhLyIAsFQ0_i0oerP7KhVDs
  public key: <the value of the "ecdh" parameter>
]]></artwork></figure>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<section anchor="the-aesgcm-128-http-content-coding" title="The “aesgcm-128” HTTP content-coding">

<t>This memo registers the “encrypted” HTTP content-coding in the HTTP Content Codings Registry, as
detailed in <xref target="aesgcm128"/>.</t>

<t><list style="symbols">
  <t>Name: aesgcm-128</t>
  <t>Description: AES-GCM encryption with a 128-bit key</t>
  <t>Reference [this specification]</t>
</list></t>

</section>
<section anchor="the-encryption-http-header-field" title="The “Encryption” HTTP header field">

<t>This memo registers the “Encryption” HTTP header field in the Permanent Message Header Registry, as
detailed in <xref target="encryption"/>.</t>

<t><list style="symbols">
  <t>Field name: Encryption</t>
  <t>Protocol: HTTP</t>
  <t>Status: Standard</t>
  <t>Reference: [this specification]</t>
  <t>Notes:</t>
</list></t>

</section>
<section anchor="cipher-registry" title="The HTTP Encryption Registry">

<t>This memo establishes a registry for parameters used by the “Encryption” header
field under the “Hypertext Transfer Protocol (HTTP) Parameters” grouping.  The
“Hypertext Transfer Protocol (HTTP) Encryption Parameters” operates under an
“Specification Required” policy <xref target="RFC5226"></xref>.</t>

<t>Entries in this registry are expected to include the following information:</t>

<t><list style="hanging">
  <t hangText='Parameter Name:'>
  The name of the parameter.
Purpose:</t>
  <t>A brief description of the purpose of the parameter.
Reference:</t>
  <t>A reference to a specification that defines the semantics of the parameter.</t>
</list></t>

<t>The initial contents of this registry are:</t>

<t><list style="hanging">
  <t hangText='Parameter Name:'>
  keyid
Purpose:</t>
  <t>Identify the key that is in use.</t>
  <t hangText='Parameter Name:'>
  key
Purpose:</t>
  <t>Provide an explicit key.</t>
  <t hangText='Parameter Name:'>
  ecdh
Purpose:</t>
  <t>Carry an elliptic curve Diffie-Hellman share used to derive a key.</t>
  <t hangText='Parameter Name:'>
  nonce
Purpose:</t>
  <t>Provide a source of entropy for derivation of the content encryption key.
This value is mandatory.</t>
  <t hangText='Parameter Name:'>
  bs
Purpose:</t>
  <t>The size of the encrypted blocks.</t>
</list></t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This mechanism assumes the presence of a key management framework that is used to manage the
distribution of keys between valid senders and receivers.  Defining key management is part of
composing this mechanism into a larger application, protocol, or framework.</t>

<t>Implementation of cryptography can be difficult.  For instance, implementations need to account for
the potential for exposing keying material on side channels, such as might be exposed by the time it
takes to perform a given operation.  The requirements for a good implementation of cryptographic
algorithms can change over time.</t>

<section anchor="content-integrity" title="Content Integrity">

<t>This mechanism does not provide any means of authenticating the origin of content.  The
authentication tag only ensures that those with access to the encryption and decryption keys can
produce valid content.</t>

</section>
<section anchor="leaking-information-in-headers" title="Leaking Information in Headers">

<t>Because “encrypted” only operates upon the message payload, any information exposed in headers is
visible to anyone who can read the message.</t>

<t>For example, the Content-Type header can leak information about the message payload.</t>

<t>There are a number of strategies available to mitigate this threat, depending upon the
application’s threat model and the users’ tolerance for leaked information:</t>

<t><list style="numbers">
  <t>Determine that it is not an issue. For example, if it is expected that all content stored will be
“application/json”, or another very common media type, exposing the Content-Type header could be an
acceptable risk.</t>
  <t>If it is considered sensitive information and it is possible to determine it through other means
(e.g., out of band, using hints in other representations, etc.), omit the relevant headers, and/or
normalize them. In the case of Content-Type, this could be accomplished by always sending
Content-Type: application/octet-stream (the most generic media type).</t>
  <t>If it is considered sensitive information and it is not possible to convey it elsewhere,
encapsulate the HTTP message using the application/http media type <xref target="RFC7230"></xref>, encrypting that as the
payload of the “outer” message.</t>
</list></t>

</section>
<section anchor="poisoning-storage" title="Poisoning Storage">

<t>This mechanism only offers encryption of content; it does not perform authentication or
authorization, which still needs to be performed (e.g., by HTTP authentication <xref target="RFC7235"></xref>).</t>

<t>This is especially relevant when a HTTP PUT request is accepted by a server; if the request is
unauthenticated, it becomes possible for a third party to deny service and/or poison the store.</t>

</section>
<section anchor="sizing-and-timing-attacks" title="Sizing and Timing Attacks">

<t>Applications using this mechanism need to be aware that the size of encrypted messages, as well as
their timing, HTTP methods, URIs and so on, may leak sensitive information.</t>

<t>This risk can be mitigated through the use of the padding that this mechanism provides.
Alternatively, splitting up content into segments and storing the separately might reduce
exposure. HTTP/2 <xref target="I-D.ietf-httpbis-http2"></xref> combined with TLS <xref target="RFC5246"></xref> might be used to hide the size
of individual messages.</t>

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>



<reference anchor='RFC4492'>

<front>
<title>Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)</title>
<author initials='S.' surname='Blake-Wilson' fullname='S. Blake-Wilson'>
<organization /></author>
<author initials='N.' surname='Bolyard' fullname='N. Bolyard'>
<organization /></author>
<author initials='V.' surname='Gupta' fullname='V. Gupta'>
<organization /></author>
<author initials='C.' surname='Hawk' fullname='C. Hawk'>
<organization /></author>
<author initials='B.' surname='Moeller' fullname='B. Moeller'>
<organization /></author>
<date year='2006' month='May' />
<abstract>
<t>This document describes new key exchange algorithms based on Elliptic Curve Cryptography (ECC) for the Transport Layer Security (TLS) protocol.  In particular, it specifies the use of Elliptic Curve Diffie-Hellman (ECDH) key agreement in a TLS handshake and the use of Elliptic Curve Digital Signature Algorithm (ECDSA) as a new authentication mechanism.  This memo provides information for the Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='4492' />
<format type='TXT' octets='72231' target='http://www.rfc-editor.org/rfc/rfc4492.txt' />
</reference>



<reference anchor='RFC4648'>

<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'>
<organization /></author>
<date year='2006' month='October' />
<abstract>
<t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4648' />
<format type='TXT' octets='35491' target='http://www.rfc-editor.org/rfc/rfc4648.txt' />
</reference>



<reference anchor='RFC7230'>

<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding'>
<organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke'>
<organization /></author>
<date year='2014' month='June' />
<abstract>
<t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract></front>

<seriesInfo name='RFC' value='7230' />
<format type='TXT' octets='205947' target='http://www.rfc-editor.org/rfc/rfc7230.txt' />
</reference>



<reference anchor='RFC7231'>

<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding'>
<organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke'>
<organization /></author>
<date year='2014' month='June' />
<abstract>
<t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract></front>

<seriesInfo name='RFC' value='7231' />
<format type='TXT' octets='235053' target='http://www.rfc-editor.org/rfc/rfc7231.txt' />
</reference>


<reference anchor="AES" >
  <front>
    <title>Advanced Encryption Standard (AES)</title>
    <author >
      <organization>National Institute of Standards and Technology (NIST)</organization>
    </author>
    <date year="2001" month="November"/>
  </front>
  <seriesInfo name="FIPS PUB 197" value=""/>
</reference>
<reference anchor="NIST80038D" >
  <front>
    <title>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</title>
    <author >
      <organization>National Institute of Standards and Technology (NIST)</organization>
    </author>
    <date year="2001" month="December"/>
  </front>
  <seriesInfo name="NIST PUB 800-38D" value=""/>
</reference>
<reference anchor="FIPS180-2" >
  <front>
    <title>NIST FIPS 180-2, Secure Hash Standard</title>
    <author initials="National Institute of Standards and Technology, U.S." surname="Department of Commerce" fullname="NIST">
      <organization></organization>
    </author>
    <date year="2002" month="August"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>





<reference anchor='RFC5226'>

<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'>
<organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
<organization /></author>
<date year='2008' month='May' />
<abstract>
<t>Many protocols make use of identifiers consisting of constants and other well-known values. Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec). To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority. For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).&lt;/t>&lt;t> In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made. If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role. This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.&lt;/t>&lt;t> This document obsoletes RFC 2434. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract></front>

<seriesInfo name='BCP' value='26' />
<seriesInfo name='RFC' value='5226' />
<format type='TXT' octets='66160' target='http://www.rfc-editor.org/rfc/rfc5226.txt' />
</reference>



<reference anchor='RFC5246'>

<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='http://www.rfc-editor.org/rfc/rfc5246.txt' />
</reference>



<reference anchor='RFC7235'>

<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding'>
<organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke'>
<organization /></author>
<date year='2014' month='June' />
<abstract>
<t>The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypermedia information systems.  This document defines the HTTP Authentication framework.</t></abstract></front>

<seriesInfo name='RFC' value='7235' />
<format type='TXT' octets='38142' target='http://www.rfc-editor.org/rfc/rfc7235.txt' />
</reference>



<reference anchor='I-D.ietf-httpbis-http2'>
<front>
<title>Hypertext Transfer Protocol version 2</title>

<author initials='M' surname='Belshe' fullname='Mike Belshe'>
    <organization />
</author>

<author initials='R' surname='Peon' fullname='Roberto Peon'>
    <organization />
</author>

<author initials='M' surname='Thomson' fullname='Martin Thomson'>
    <organization />
</author>

<date month='November' day='29' year='2014' />

<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent messages on the same connection.  It also introduces unsolicited push of representations from servers to clients.  This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-http2-16' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-http2-16.txt' />
</reference>


<reference anchor="FIPS186" >
  <front>
    <title>Digital Signature Standard (DSS)</title>
    <author >
      <organization>National Institute of Standards and Technology (NIST)</organization>
    </author>
    <date year="2013" month="July"/>
  </front>
  <seriesInfo name="NIST PUB 186-4" value=""/>
</reference>
<reference anchor="X.692" >
  <front>
    <title>Public Key Cryptography For The Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</title>
    <author >
      <organization>ANSI</organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="ANSI X9.62, 1998." value=""/>
</reference>


    </references>



  </back>
</rfc>

