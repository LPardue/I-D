<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head profile="http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The Key HTTP Response Header Field</title><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
    body {
      padding-top: 80px;
      padding-bottom: 80px;
      position: relative;
    }
    .table.header th, .table.header td { 
      border-top: none; 
      padding: 0;
    }
    .nav-sublist {
      padding-left: 20px;
      padding-right: 10px;
      font-size: 90%;
    }
    .container .nav > li > a {
      padding-top: 10px;
      display: inline-block;
    }
  </style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The “Key” Response Header Field" href="#rfc.section.2"><link rel="Chapter" title="3 IANA Considerations" href="#rfc.section.3"><link rel="Chapter" title="4 Security Considerations" href="#rfc.section.4"><link rel="Chapter" href="#rfc.section.5" title="5 Normative References"><link rel="Appendix" title="A Acknowledgements" href="#rfc.section.A"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.662, 2014/07/19 09:19:17, XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Fielding, R."><meta name="dct.creator" content="Nottingham, M."><meta name="dct.identifier" content="urn:ietf:id:draft-fielding-http-key-03"><meta name="dct.issued" scheme="ISO8601" content="2015-09-02"><meta name="dct.abstract" content="The ‘Key’ header field for HTTP responses allows an origin server to describe the secondary cache key (, section 4.1) for a resource, by conveying what is effectively a short algorithm that can be used upon later requests to determine if a stored response is reusable for a given request.Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending request header fields in order to reduce the risk of fingerprinting."><meta name="description" content="The ‘Key’ header field for HTTP responses allows an origin server to describe the secondary cache key (, section 4.1) for a resource, by conveying what is effectively a short algorithm that can be used upon later requests to determine if a stored response is reusable for a given request.Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending request header fields in order to reduce the risk of fingerprinting."></head><body data-spy="scroll" data-target="#rfc.toc"><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 affix hidden-sm hidden-xs" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">Internet-Draft</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a> <a href="#introduction" data-toggle="collapse" data-target="#toc.introduction">Introduction</a><div class="collapse" id="toc.introduction"><ul class="nav-sublist list-unstyled"><li><a href="#rfc.section.1.1">1.1</a> <a href="#examples">Examples</a></li><li><a href="#rfc.section.1.2">1.2</a> <a href="#notational-conventions">Notational Conventions</a></li></ul></div></li><li><a href="#rfc.section.2">2.</a> <a href="#the-key-response-header-field" data-toggle="collapse" data-target="#toc.the-key-response-header-field">The “Key” Response Header Field</a><div class="collapse" id="toc.the-key-response-header-field"><ul class="nav-sublist list-unstyled"><li><a href="#rfc.section.2.1">2.1</a> <a href="#relationship-to-vary">Relationship to Vary</a></li><li><a href="#rfc.section.2.2">2.2</a> <a href="#calculating-a-secondary-cache-key" data-toggle="collapse" data-target="#toc.calculating-a-secondary-cache-key">Calculating a Secondary Cache Key</a><div class="collapse" id="toc.calculating-a-secondary-cache-key"><ul class="nav-sublist list-unstyled"><li><a href="#rfc.section.2.2.1">2.2.1</a> <a href="#value">Creating a Header Field Value</a></li><li><a href="#rfc.section.2.2.2">2.2.2</a> <a href="#fail-param">Failing Parameter Processing</a></li></ul></div></li><li><a href="#rfc.section.2.3">2.3</a> <a href="#key-parameters" data-toggle="collapse" data-target="#toc.key-parameters">Key Parameters</a><div class="collapse" id="toc.key-parameters"><ul class="nav-sublist list-unstyled"><li><a href="#rfc.section.2.3.1">2.3.1</a> <a href="#div">div</a></li><li><a href="#rfc.section.2.3.2">2.3.2</a> <a href="#range">range</a></li><li><a href="#rfc.section.2.3.3">2.3.3</a> <a href="#match">match</a></li><li><a href="#rfc.section.2.3.4">2.3.4</a> <a href="#substr">substr</a></li><li><a href="#rfc.section.2.3.5">2.3.5</a> <a href="#param">param</a></li></ul></div></li></ul></div></li><li><a href="#rfc.section.3">3.</a> <a href="#iana" data-toggle="collapse" data-target="#toc.iana">IANA Considerations</a><div class="collapse" id="toc.iana"><ul class="nav-sublist list-unstyled"><li><a href="#rfc.section.3.1">3.1</a> <a href="#procedure">Procedure</a></li><li><a href="#rfc.section.3.2">3.2</a> <a href="#registrations">Registrations</a></li></ul></div></li><li><a href="#rfc.section.4">4.</a> <a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.5">5.</a> <a href="#rfc.references" data-toggle="collapse" data-target="#toc.references">Normative References</a></li><li><a href="#rfc.section.A">A.</a> <a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div></div></div></div><div class="col-md-8 main" role="main"><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">R. Fielding</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">Adobe Systems Incorporated</td></tr><tr><td class="text-left"><strong>Intended status: </strong>Informational</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left"><strong>Expires: </strong>March 5, 2016</td><td class="text-right">September 2, 2015</td></tr></tbody></table><div class="page-header"><h1 class="title" id="rfc.title">The Key HTTP Response Header Field<br><small>draft-fielding-http-key-03</small></h1></div><h1 id="rfc.abstract">Abstract</h1><div class="lead"><p>The ‘Key’ header field for HTTP responses allows an origin server to describe the secondary cache key (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, section 4.1) for a resource, by conveying what is effectively a short algorithm that can be used upon later requests to determine if a stored response is reusable for a given request.</p><p>Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.</p><p>Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending request header fields in order to reduce the risk of fingerprinting.</p></div><h1 id="rfc.note.1"><a href="#rfc.note.1">Note to Readers</a></h1><p>The issues list for this draft can be found at <a href="https://github.com/mnot/I-D/labels/key">https://github.com/mnot/I-D/labels/key</a>.</p><div id="rfc.status"><h1>Status of this Memo</h1><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on March 5, 2016.</p></div><div id="rfc.copyrightnotice"><h1>Copyright Notice</h1><p>Copyright © 2015 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div><div id="introduction"><h1 id="rfc.section.1" class="np">1.&nbsp;Introduction</h1><p id="rfc.section.1.p.1">In HTTP caching <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, the Vary response header field effectively modifies the key used to store and access a response to include information from the request’s headers. This allows proactive content negotiation <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> to work with caches.</p><p id="rfc.section.1.p.2">However, Vary’s operation is coarse-grained; although caches are allowed to normalise the values of headers based upon their semantics, doing so requires the cache to understand those semantics, and is therefore limited in utility.</p><p id="rfc.section.1.p.3">For example, if a response is cached with the response header field:</p><div id="rfc.figure.u.1"><pre>
  Vary: Accept-Encoding
</pre></div><p id="rfc.section.1.p.4">and and its associated request is:</p><div id="rfc.figure.u.2"><pre>
  Accept-Encoding: gzip
</pre></div><p id="rfc.section.1.p.5">then a subsequent request presented with the following header is (in a strict reading of HTTP) not a match, resulting in a cache miss:</p><div id="rfc.figure.u.3"><pre>
  Accept-Encoding: identity, gzip
</pre></div><p id="rfc.section.1.p.6">This document defines a new response header field, “Key”, that allows servers to describe the cache key in a much more fine-grained manner, leading to improved cache efficiency.</p><div id="examples"><h2 id="rfc.section.1.1">1.1&nbsp;Examples</h2><p id="rfc.section.1.1.p.1">For example, this response header field:</p><div id="rfc.figure.u.4"><pre>
  Key: cookie;param=_sess;param=ID, 
       Accept-Encoding;match="gzip"
</pre></div><p id="rfc.section.1.1.p.2">instructs caches to create a secondary cache key that consists of the “_sess” and “ID” cookie values, as well as whether the Accept-Encoding header contains the whole value “gzip”.</p><p id="rfc.section.1.1.p.3">This Key:</p><div id="rfc.figure.u.5"><pre>
  Key: user-agent;substr=MSIE
</pre></div><p id="rfc.section.1.1.p.4">indicates that there are two possible secondary cache keys for this resource; one for requests whose User-Agent header field contains “MSIE”, and another for those that don’t.</p><p id="rfc.section.1.1.p.5">A more complex example:</p><div id="rfc.figure.u.6"><pre>
  Key: user-agent;substr=MSIE;Substr="mobile";substr=bot
</pre></div><p id="rfc.section.1.1.p.6">indicates that there are eight possible secondary cache keys.</p></div><div id="notational-conventions"><h2 id="rfc.section.1.2">1.2&nbsp;Notational Conventions</h2><p id="rfc.section.1.2.p.1">The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p><p id="rfc.section.1.2.p.2">This document uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a> (including the DQUOTE rule), and the list rule extension defined in <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 7. It includes by reference the field-name, quoted-string and quoted-pair rules from that document, and the parameter rule from <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>.</p></div></div><div id="the-key-response-header-field"><h1 id="rfc.section.2">2.&nbsp;The “Key” Response Header Field</h1><p id="rfc.section.2.p.1">The “Key” response header field describes the portions of the request that the resource currently uses to select representations.</p><p id="rfc.section.2.p.2">As such, its semantics are similar to the “Vary” response header field, but it allows more fine-grained description, using “key parameters”.</p><p id="rfc.section.2.p.3">Caches can use this information as part of determining whether a stored response can be used to satisfy a given request. When a cache knows and fully understands the Key header field for a given resource, it MAY ignore the Vary response header field in any stored responses for it.</p><p id="rfc.section.2.p.4">Additionally, user agents can use Key to discover if additional request header fields might influence the resource’s selection of responses.</p><p id="rfc.section.2.p.5">The Key field-value is a comma-delimited list of selecting header fields (similar to Vary), with zero to many parameters each, delimited by semicolons. Whitespace is not allowed in the field-value between each field-name and its parameter set.</p><div id="rfc.figure.u.7"><pre>
  Key = 1#field-name *( ";" parameter )
</pre></div><p id="rfc.section.2.p.6">Note that, as per <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, parameter names are case-insensitive, and parameter values can be double-quoted strings (potentially with “"-escaped characters inside).</p><p id="rfc.section.2.p.7">The following header fields have the same effect:</p><div id="rfc.figure.u.8"><pre>
  Vary: Accept-Encoding, Cookie
  Key: Accept-Encoding, Cookie
</pre></div><p id="rfc.section.2.p.8">However, Key’s use of parameters allows:</p><div id="rfc.figure.u.9"><pre>
  Key: Accept-Encoding;match="gzip", Cookie;param=foo
</pre></div><p id="rfc.section.2.p.9">to indicate that the secondary cache key depends upon whether requests contain the whole value “gzip” (in any case) in the Accept-Encoding header field, and the “foo” Cookie.</p><p id="rfc.section.2.p.10">One important difference between Vary and Key is how they are applied. Vary is specified to be specific to the response it occurs within, whereas Key is specific to the resource (as identified by the request URL) it is associated with. The most recent key you receive for a given resource is applicable to all responses from that resource.</p><p id="rfc.section.2.p.11">This difference allows more efficient implementation (and reflects practices that many caches use in implementing Vary already).</p><p id="rfc.section.2.p.12">This specification defines a selection of Key parameters to address common use cases such as selection upon Acccept-Encoding values, individual Cookie header fields, User-Agent substrings and numerical ranges. Future parameters may define further capabilities.</p><div id="relationship-to-vary"><h2 id="rfc.section.2.1">2.1&nbsp;Relationship to Vary</h2><p id="rfc.section.2.1.p.1">Origin servers SHOULD still send Vary when using Key, to accommodate implementations that do not (yet) understand it. For example,</p><div id="rfc.figure.u.10"><pre>
  Vary: Accept-Encoding
  Key: Accept-Encoding;match="gzip"
</pre></div></div><div id="calculating-a-secondary-cache-key"><h2 id="rfc.section.2.2">2.2&nbsp;Calculating a Secondary Cache Key</h2><p id="rfc.section.2.2.p.1">When used by a cache to determine whether a stored response can be used to satisfy a presented request, each field-name in Key identifies a potential request header, just as with the Vary response header field.</p><p id="rfc.section.2.2.p.2">However, each of these can have zero to many key parameters that change how the response selection process (as defined in <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.3)) works.</p><p id="rfc.section.2.2.p.3">In particular, when a cache fully implements this specification, it creates a secondary cache key for every request by following the instructions in the Key header field, ignoring the Vary header for this purpose.</p><p id="rfc.section.2.2.p.4">Then, when a new request is presented, the secondary cache key generated for that request can be compared to the stored one to find the appropriate response, to determine if it can be selected.</p><p id="rfc.section.2.2.p.5">To generate a secondary cache key for a given request (including that which is stored with a response) using Key, the following steps are taken:</p><ol><li>Let <samp>key_value</samp> be the most recently seen Key header field value for the resource, as the result of Creating a Header Field Value (<a href="#value" title="Creating a Header Field Value">Section&nbsp;2.2.1</a>).</li><li>Let <samp>secondary_key</samp> be an empty string.</li><li>Create <samp>key_list</samp> by splitting <samp>key_value</samp> on “,” characters.</li><li>For <samp>key_item</samp> in <samp>key_list</samp>: <ol><li>Remove any leading and trailing WSP from <samp>key_item</samp>.</li><li>If <samp>key_item</samp> does not contain a “;” character, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <samp>key_item</samp>.</li><li>Let <samp>field_name</samp> be the string before the first “;” character in <samp>key_item</samp>.</li><li>Let <samp>field_value</samp> be the result of Creating a Header Field Value (<a href="#value" title="Creating a Header Field Value">Section&nbsp;2.2.1</a>) with <samp>field_name</samp> as the <samp>target_field_name</samp> and the request header list as <samp>header_list</samp>.</li><li>Let <samp>parameters</samp> be the string after the first “;” character in <samp>key_item</samp>.</li><li>Create <samp>param_list</samp> by splitting <samp>parameters</samp> on “;” characters, excepting “;” characters within quoted strings, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> Section 3.2.6.</li><li>For <samp>parameter</samp> in <samp>param_list</samp>: <ol><li>If <samp>parameter</samp> does not contain a “=”, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <samp>key_item</samp>.</li><li>Let <samp>param_name</samp> be the string before the first “=” character in <samp>parameter</samp>, case-normalized to lowercase.</li><li>If <samp>param_name</samp> does not identify a Key parameter processing algorithm that is implemented, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <samp>key_item</samp>.</li><li>Let <samp>param_value</samp> be the string after the first “=” character in <samp>parameter</samp>.</li><li>If the first and last characters of <samp>param_value</samp> are both DQUOTE: <ol><li>Remove the first and last characters of <samp>param_value</samp>.</li><li>Replace quoted-pairs within <samp>param_value</samp> with the octet following the backslash, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> Section 3.2.6.</li></ol></li><li>If <samp>param_value</samp> does not conform to the syntax defined for it by the parameter definition, fail parameter processing <a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a> and skip to the next <samp>key_item</samp>.</li><li>Run the identified processing algorithm on <samp>field_value</samp> with the <samp>param_value</samp>, and append the result to <samp>secondary_key</samp>. If parameter processing fails <a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>, skip to the next <samp>key_item</samp>.</li><li>Append a separator character (e.g., NULL) to <samp>secondary_key</samp>.</li></ol></li></ol></li><li>Return <samp>secondary_key</samp>.</li></ol><p id="rfc.section.2.2.p.7">Note that this specification does not require that exact algorithm to be implemented. However, implementations’ observable behavior MUST be identical to running it. This includes parameter processing algorithms; implementations MAY use different internal artefacts for secondary cache keys, as long as the results are the same.</p><p id="rfc.section.2.2.p.8">Likewise, while the secondary cache key associated with both stored and presented requests is required to use the most recently seen Key header field for the resource in question, this can be achieved using a variety of implementation strategies, including (but not limited to):</p><ul><li>Generating a new secondary cache key for every stored response associated with the resource upon each request.</li><li>Caching the secondary cache key with the stored request/response pair and re-generating it when the Key header field is observed to change.</li><li>Caching the secondary cache key with the stored response and invalidating the stored response(s) when the Key header field is observed to change.</li></ul><div id="value"><h3 id="rfc.section.2.2.1">2.2.1&nbsp;Creating a Header Field Value</h3><p id="rfc.section.2.2.1.p.1">Given a header field name <samp>target_field_name</samp> and <samp>header_list</samp>, a list of (<samp>field_name</samp>, <samp>field_value</samp>) tuples:</p><ol><li>Let <samp>target_field_values</samp> be an empty list.</li><li>For each (<samp>field_name</samp>, <samp>field_value</samp>) tuple in <samp>header_list</samp>: <ol><li>If <samp>field_name</samp> does not match <samp>target_field_name</samp>, skip to the next tuple.</li><li>Strip leading and trailing WSP from <samp>field_value</samp> and append it to <samp>target_field_values</samp>.</li></ol></li><li>If <samp>target_field_values</samp> is empty, return an empty string.</li><li>Return the concatenation of <samp>target_field_values</samp>, separating each with “,” characters.</li></ol></div><div id="fail-param"><h3 id="rfc.section.2.2.2">2.2.2&nbsp;Failing Parameter Processing</h3><p id="rfc.section.2.2.2.p.1">In some cases, a key parameter cannot determine a secondary cache key corresponding to its nominated header field value. When this happens, Key processing needs to fail safely, so that the correct behavior is observed.</p><p id="rfc.section.2.2.2.p.2">When this happens, implementations MUST either behave as if the Key header was not present, or assure that the nominated header fields being compared match, as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.1.</p></div></div><div id="key-parameters"><h2 id="rfc.section.2.3">2.3&nbsp;Key Parameters</h2><p id="rfc.section.2.3.p.1">A Key parameter associates a name with a specific processing algorithm that takes two inputs; a HTTP header value “header_value” (as described in <a href="#value" title="Creating a Header Field Value">Section&nbsp;2.2.1</a>), and “parameter_value”, a string that indicates how the identified header should be processed.</p><p id="rfc.section.2.3.p.2">The set of key parameters (and their associated processing algorithms) is extensible; see <a href="#iana" title="IANA Considerations">Section&nbsp;3</a>. This document defines the following key parameters:</p><div id="div"><h3 id="rfc.section.2.3.1">2.3.1&nbsp;div</h3><p id="rfc.section.2.3.1.p.1">The “div” parameter normalizes positive integer header values into groups by dividing them by a configured value.</p><p id="rfc.section.2.3.1.p.2">Its value’s syntax is:</p><div id="rfc.figure.u.11"><pre>
div    = 1*DIGIT
</pre></div><p id="rfc.section.2.3.1.p.3">To process a set of header fields against a div parameter, follow these steps (or their equivalent):</p><ol><li>If <samp>parameter_value</samp> is “0”, fail parameter processing <a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>.</li><li>If <samp>header_value</samp> is the empty string, return “none”.</li><li>If <samp>header_value</samp> contains a “,”, remove it and all subsequent characters.</li><li>Remove all WSP characters from <samp>header_value</samp>.</li><li>If <samp>header_value</samp> does not match the div ABNF rule, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>).</li><li>Return the quotient of <samp>header_value</samp> / <samp>parameter_value</samp> (omitting the modulus).</li></ol><p id="rfc.section.2.3.1.p.5">For example, the Key:</p><div id="rfc.figure.u.12"><pre>
Key: Bar;div=5
</pre></div><p id="rfc.section.2.3.1.p.6">indicates that the “Bar” header’s field value should be segmented into groups of 5. Thus, the following field values would be considered the same:</p><div id="rfc.figure.u.13"><pre>
Bar: 1
Bar: 3 , 42
Bar: 4, 1
</pre></div><p id="rfc.section.2.3.1.p.7">whereas these would be considered to be in a different group;</p><div id="rfc.figure.u.14"><pre>
Bar: 12
Bar: 10
Bar: 14, 1
</pre></div></div><div id="range"><h3 id="rfc.section.2.3.2">2.3.2&nbsp;range</h3><p id="rfc.section.2.3.2.p.1">The “range” parameter normalizes positive numeric header values into pre-defined “buckets”.</p><p id="rfc.section.2.3.2.p.2">Its value’s syntax is:</p><div id="rfc.figure.u.15"><pre>
range  = [ bucket ] *( ":" [ bucket ] )
bucket = [ 0*DIGIT "." ] 1*DIGIT
</pre></div><p id="rfc.section.2.3.2.p.3">To process a set of header fields against a range parameter, follow these steps (or their equivalent):</p><ol><li>If <samp>header_value</samp> is the empty string, return “none”.</li><li>If <samp>header_value</samp> contains a “,”, remove it and all subsequent characters.</li><li>Remove all WSP characters from <samp>header_value</samp>.</li><li>If <samp>header_value</samp> does not match the bucket ABNF rule, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>).</li><li>Let <samp>bucket_id</samp> be 0.</li><li>Create a list <samp>bucket_list</samp> by splitting <samp>parameter_value</samp> on “:” characters.</li><li>For each <samp>bucket_value</samp> in <samp>bucket_list</samp>: <ol><li>If <samp>header_value</samp> is less than <samp>bucket_value</samp> when they are numerically compared, skip to step 7.</li><li>Increment <samp>bucket_id</samp> by 1.</li></ol></li><li>Return <samp>bucket_id</samp>.</li></ol><p id="rfc.section.2.3.2.p.5">For example, the Key:</p><div id="rfc.figure.u.16"><pre>
Key: Foo;range=20:30:40
</pre></div><p id="rfc.section.2.3.2.p.6">indicates that the “Foo” header’s field value should be divided into four “buckets”:</p><ul><li>less than 20</li><li>20 to less than 30</li><li>30 to less than 40</li><li>forty or greater</li></ul><p id="rfc.section.2.3.2.p.8">Thus, the following headers would all be normalized to the first bucket:</p><div id="rfc.figure.u.17"><pre>
Foo: 1
Foo: 0
Foo: 4, 54
Foo: 19.9
</pre></div><p id="rfc.section.2.3.2.p.9">whereas the following would fall into the second bucket:</p><div id="rfc.figure.u.18"><pre>
Foo: 20
Foo: 29.999
Foo:  24   , 10
</pre></div></div><div id="match"><h3 id="rfc.section.2.3.3">2.3.3&nbsp;match</h3><p id="rfc.section.2.3.3.p.1">The “match” parameter is used to determine if an exact value occurs in a list of header values. It is case-sensitive.</p><p id="rfc.section.2.3.3.p.2">Its value’s syntax is:</p><div id="rfc.figure.u.19"><pre>
match  = token
</pre></div><p id="rfc.section.2.3.3.p.3">To process a set of header fields against a match parameter, follow these steps (or their equivalent):</p><ol><li>If <samp>header_value</samp> is the empty string, return “none”.</li><li>Create <samp>header_list</samp> by splitting <samp>header_value</samp> on “,” characters.</li><li>For each <samp>header_item</samp> in <samp>header_list</samp>: <ol><li>Remove leading and trailing WSP characters in <samp>header_item</samp>.</li><li>If the value of <samp>header_item</samp> is character-for-character identical to <samp>parameter_value</samp>, return “1”.</li></ol></li><li>Return “0”.</li></ol><p id="rfc.section.2.3.3.p.5">For example, the Key:</p><div id="rfc.figure.u.20"><pre>
Key: Baz;match="charlie"
</pre></div><p id="rfc.section.2.3.3.p.6">Would return “1” for the following header field values:</p><div id="rfc.figure.u.21"><pre>
Baz: charlie
Baz: foo, charlie
Baz: bar, charlie     , abc
</pre></div><p id="rfc.section.2.3.3.p.7">and “0” for these:</p><div id="rfc.figure.u.22"><pre>
Baz: theodore
Baz: joe, sam
Baz: "charlie"
Baz: Charlie
Baz: cha rlie
Baz: charlie2
</pre></div></div><div id="substr"><h3 id="rfc.section.2.3.4">2.3.4&nbsp;substr</h3><p id="rfc.section.2.3.4.p.1">The “substr” parameter is used to determine if a value occurs as a substring of an item in a list of header values. It is case-sensitive.</p><p id="rfc.section.2.3.4.p.2">Its value’s syntax is:</p><div id="rfc.figure.u.23"><pre>
substr  = token
</pre></div><p id="rfc.section.2.3.4.p.3">To process a set of header fields against a substr parameter, follow these steps (or their equivalent):</p><ol><li>If <samp>header_value</samp> is the empty string, return “none”.</li><li>Create <samp>header_list</samp> by splitting <samp>header_value</samp> on “,” characters.</li><li>For each <samp>header_item</samp> in <samp>header_list</samp>: <ol><li>Remove leading and trailing WSP characters in <samp>header_item</samp>.</li><li>If the value of <samp>parameter_value</samp> is character-for-character present as a substring of <samp>header_value</samp>, return “1”.</li></ol></li><li>Return “0”.</li></ol><p id="rfc.section.2.3.4.p.5">For example, the Key:</p><div id="rfc.figure.u.24"><pre>
Key: Abc;substr=bennet
</pre></div><p id="rfc.section.2.3.4.p.6">Would return “1” for the following header field values:</p><div id="rfc.figure.u.25"><pre>
Abc: bennet
Abc: foo, bennet
Abc: abennet00
Abc: bar, 99bennet     , abc
Abc: "bennet"
</pre></div><p id="rfc.section.2.3.4.p.7">and “0” for these:</p><div id="rfc.figure.u.26"><pre>
Abc: theodore
Abc: joe, sam
Abc: Bennet
Abc: Ben net
</pre></div></div><div id="param"><h3 id="rfc.section.2.3.5">2.3.5&nbsp;param</h3><p id="rfc.section.2.3.5.p.1">The “param” parameter considers the request header field as a list of key=value parameters, and uses the nominated key’s value as the secondary cache key.</p><p id="rfc.section.2.3.5.p.2">Its value’s syntax is:</p><div id="rfc.figure.u.27"><pre>
param  = token
</pre></div><p id="rfc.section.2.3.5.p.3">To process a list of header fields against a param parameter, follow these steps (or their equivalent):</p><ol><li>Let <samp>header_list</samp> be an empty list.</li><li>Create <samp>header_list_tmp1</samp> by splitting header_value on “,” characters.</li><li>For each <samp>header_item_tmp1</samp> in <samp>header_list_tmp1</samp>: <ol><li>Create <samp>header_list_tmp2</samp> by splitting <samp>header_item_tmp1</samp> on “;” characters.</li><li>For each <samp>header_item_tmp2</samp> in <samp>header_list_tmp2</samp>: <ol><li>Remove leading and trailing WSP from <samp>header_item_tmp2</samp>.</li><li>Append <samp>header_item_tmp2</samp> to header_list.</li></ol></li></ol></li><li>For each <samp>header_item</samp> in <samp>header_list</samp>: <ol><li>If the “=” character does not occur within <samp>header_item</samp>, skip to the next <samp>header_item</samp>.</li><li>Let <samp>item_name</samp> be the string occurring before the first “=” character in <samp>header_item</samp>.</li><li>If <samp>item_name</samp> does not case-insensitively match <samp>parameter_value</samp>, skip to the next <samp>header_item</samp>.</li><li>Return the string occurring after the first “=” character in <samp>header_item</samp>.</li></ol></li><li>Return the empty string.</li></ol><p id="rfc.section.2.3.5.p.5">Note that steps 2 and 3 accommodate semicolon-separated values, so that it can be used with the Cookie request header field.</p><p id="rfc.section.2.3.5.p.6">For example, the Key:</p><div id="rfc.figure.u.28"><pre>
Key: Def;param=liam
</pre></div><p id="rfc.section.2.3.5.p.7">The following headers would return the string (surrounded in single quotes) indicated:</p><div id="rfc.figure.u.29"><pre>
Def: liam=123           // '123'
Def: mno=456            // ''
Def:                    // ''
Def: abc=123; liam=890  // '890'
Def: liam="678"         // '"678"'
</pre></div></div></div></div><div id="iana"><h1 id="rfc.section.3">3.&nbsp;IANA Considerations</h1><p id="rfc.section.3.p.1">This specification defines the HTTP Key Parameter Registry, maintained at <a href="http://www.iana.org/assignments/http-parameters/http-parameters.xhtml#key">http://www.iana.org/assignments/http-parameters/http-parameters.xhtml#key</a>.</p><div id="procedure"><h2 id="rfc.section.3.1">3.1&nbsp;Procedure</h2><p id="rfc.section.3.1.p.1">Key Parameter registrations MUST include the following fields:</p><ul><li>Parameter Name: [name]</li><li>Reference: [Pointer to specification text]</li></ul><p id="rfc.section.3.1.p.3">Values to be added to this namespace require IETF Review (see Section 4.1 of [RFC5226]) and MUST conform to the purpose of content coding defined in this section.</p></div><div id="registrations"><h2 id="rfc.section.3.2">3.2&nbsp;Registrations</h2><p id="rfc.section.3.2.p.1">This specification makes the following entries in the HTTP Key Parameter Registry:</p><div id="rfc.table.u.1"><table class="table full text-center"><thead><tr><th class="left">Parameter Name</th><th class="left">Reference</th></tr></thead><tbody><tr><td class="left">div</td><td class="left"><a href="#div" title="div">Section&nbsp;2.3.1</a></td></tr><tr><td class="left">range</td><td class="left"><a href="#range" title="range">Section&nbsp;2.3.2</a></td></tr><tr><td class="left">match</td><td class="left"><a href="#match" title="match">Section&nbsp;2.3.3</a></td></tr><tr><td class="left">substr</td><td class="left"><a href="#substr" title="substr">Section&nbsp;2.3.4</a></td></tr><tr><td class="left">param</td><td class="left"><a href="#param" title="param">Section&nbsp;2.3.5</a></td></tr></tbody></table></div></div></div><div id="security-considerations"><h1 id="rfc.section.4">4.&nbsp;Security Considerations</h1><p id="rfc.section.4.p.1">Because Key is an alternative to Vary, it is possible for caches to behave differently based upon whether they implement Key. Likewise, because support for any one Key parameter is not required, it is possible for different implementations of Key to behave differently. In both cases, an attacker might be able to exploit these differences.</p><p id="rfc.section.4.p.2">This risk is mitigated by the requirement to fall back to Vary when unsupported parameters are encountered, coupled with the requirement that servers that use Key also include a relevant Vary header.</p><p id="rfc.section.4.p.3">An attacker with the ability to inject response headers might be able to perform a cache poisoning attack that tailors a response to a specific user (e.g., by Keying to a Cookie that’s specific to them). While the attack is still possible without Key, the ability to tailor is new.</p><p id="rfc.section.4.p.4">When implemented, Key might result in a larger number of stored responses for a given resource in caches; this, in turn, might be used to create an attack upon the cache itself. Good cache replacement algorithms and denial of service monitoring in cache implementations are reasonable mitigations against this risk.</p></div><h1 id="rfc.references"><a href="#rfc.section.5" id="rfc.section.5">5.</a> Normative References</h1><dl class="dl-horizontal"><dt><span id="RFC2119">[RFC2119]</span></dt><dd>Bradner, S., “<a href="http://www.rfc-editor.org/info/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, DOI&nbsp;10.17487/RFC2119, March&nbsp;1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt><span id="RFC5234">[RFC5234]</span></dt><dd>Crocker, D., Ed. and P. Overell, “<a href="http://www.rfc-editor.org/info/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD&nbsp;68, RFC&nbsp;5234, DOI&nbsp;10.17487/RFC5234, January&nbsp;2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5234">http://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt><span id="RFC7230">[RFC7230]</span></dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="http://www.rfc-editor.org/info/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, DOI&nbsp;10.17487/RFC7230, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt><span id="RFC7231">[RFC7231]</span></dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="http://www.rfc-editor.org/info/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, DOI&nbsp;10.17487/RFC7231, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt><span id="RFC7234">[RFC7234]</span></dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="http://www.rfc-editor.org/info/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC&nbsp;7234, DOI&nbsp;10.17487/RFC7234, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7234">http://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd></dl><div id="acknowledgements"><h1 id="rfc.section.A" class="np">A.&nbsp;Acknowledgements</h1><p id="rfc.section.A.p.1">Thanks to Ilya Grigorik, Amos Jeffries and Yoav Weiss for their feedback.</p></div><div class="avoidbreak"><h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1><p><b>Roy T. Fielding</b><br>Adobe Systems Incorporated<br>EMail: <a href="mailto:fielding@gbiv.com">fielding@gbiv.com</a><br>URI: <a href="http://roy.gbiv.com/">http://roy.gbiv.com/</a></p><p><b>Mark Nottingham</b><br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="http://www.mnot.net/">http://www.mnot.net/</a></p></div></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script><script type="text/javascript">
        /* This is a workaround for https://github.com/twbs/bootstrap/issues/14285 */
        $('.nav a').on('click', function(a) {$(a.target.dataset.target.replace( /(:|\.|\[|\])/g, "\\$1" )).collapse('toggle')})
      </script></body></html>