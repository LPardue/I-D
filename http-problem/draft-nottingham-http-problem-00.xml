<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE rfc SYSTEM "../xml2rfc/rfc2629.dtd" [
   <!ENTITY rfc2119 SYSTEM 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>  
   <!ENTITY rfc2616 SYSTEM 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml'>  
   <!ENTITY rfc3986 SYSTEM 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>  
   <!ENTITY rfc4627 SYSTEM 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml'>  
   <!ENTITY rfc5987 SYSTEM 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5987.xml'>  
   <!ENTITY rfc5988 SYSTEM 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5988.xml'>  
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc tocdepth="3" ?>
<?rfc tocindent="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes" ?>

<rfc ipr="trust200902" docName="draft-nottingham-http-problem-00" category="info">

	<front>
		<title abbrev="HTTP Problems">Indicating Problems to Machines in HTTP</title>
		<author initials="M." surname="Nottingham" fullname="Mark Nottingham">
			<organization>Rackspace</organization>
			<address>       
				<email>mnot@mnot.net</email> 
				<uri>http://www.mnot.net/</uri>
			</address>
		</author>
		<date year="2012"/>
		<keyword>status</keyword>
		<keyword>HTTP</keyword>
		<keyword>error</keyword>
		<keyword>problem</keyword>
		<keyword>HTTP problem</keyword>
		<abstract>

			<t>This specification proposes a "HTTP Problem" as an extensible way
         to carry machine-readable details of errors in a response, to avoid
         the need to invent new status codes and/or response formats for
         non-human consumers.</t>

		</abstract>
	</front>

	<middle>

		<section title="Introduction">

         <t>While HTTP <xref target="RFC2616"/> defines the status code as
         the primary indicator of response semantics, it is often not
         fine-grained enough to convey error semantics to non-human
         clients.</t>
         
          <t>This specification proposes a "HTTP Problem" as an extensible way
          to carry machine-readable details of errors in a response, to avoid
          the need to invent new status codes and/or response formats for
          non-human consumers.</t>
         
          <t>HTTP problems have: 
             <list style="symbols">
             <t>A generic status, identified and solely conveyed by the HTTP
             status code <eref
             target="http://www.iana.org/assignments/http-status-codes/"/>.
             For example, "403 Forbidden".</t>
             <t>An problem type that refines the status code semantics,
             identified by an absolute URI <xref target="RFC3986"/> and paired
             with a summary title.</t>
             <t>Optionally, detail that is specific to an instance
             of the problem.</t>
            </list>
         </t>
         
          <t>This specification defines a common data model for HTTP Problems
          as a JSON <xref target="RFC4627"/> object. That object can be
          serialised as an "application/json-problem" HTTP response, or it can
          be conveyed using a Link HTTP response header field <xref
          target="RFC5988"/>.</t>
         
          <t>Future work may include defining a HTML Microformat <eref
          target="http://microformats.org/"/> that allows this information to
          be carried in an HTML document as well.</t>

		</section>

		<section title="Requirements">
		   <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
		   NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in
		   this document are to be interpreted as described in <xref
		   target="RFC2119"/>.</t>
		</section>


      <section title="The HTTP Problem JSON Object">

         <t>The canonical format for a HTTP problem is a JSON <xref
         target="RFC4627"/> document, identified with the
         "application/json-problem" media type. Its root object has the
         following properties:</t>
         
         <t><list style='symbols'>
            <t>"describedBy" (string) - A URL that identifies the type of
            problem. When dereferenced, it SHOULD provide human-readable
            documentation (e.g., using HTML).</t>
            <t>"title" (string) - A short, human-readable summary of the
            problem. It SHOULD NOT change from instance to instance of the
            problem, except for purposes of localisation.</t>
            <t>"detail" (string) - Optionally, additional, human readable
            detail specific to this instance of the problem.</t>
         </list></t>
         
          <t>HTTP problems, when serialised as JSON objects, MUST include the
          "describedBy" and "title" properties. The "detail" property is
          always OPTIONAL.</t>
         
          <t>Problem types MAY extend their instances with additional
          properties. For example:</t>

         <figure><artwork><![CDATA[
   HTTP/1.1 403 Forbidden
   Content-Type: application/json-problem
   Content-Language: en

   {
     "describedBy": "http://example.com/probs/out-of-credit",
     "title": "You do not have enough credits.",
     "detail": "Your current balance is 30, but that costs 50.",
     "balance": 30,
     "account": "http://api.example.com/account/12345"
   }]]></artwork></figure>

         <t>Here, the out-of-credit problem (identified by its URI) indicates
         the reason for the 403 in "title", gives instance-specific
         details in "detail", and adds two extensions; "balance" conveys the
         account's balance, and "account" gives a link where the account can
         be topped up.</t>

         <t>Note that "describedBy" is case-sensitive in the JSON object, as
            are all other property names.</t>

      </section>

      <section anchor="the-problem-http-response-header-field" title="Expressing Problems with Link Headers">

      <t>Because resources often use formats other than JSON to convey
      human-readable problem details, it is also possible to serialise a HTTP
      Problem for machine consumption using a Link response header field <xref
      target="RFC5988"/>. For example:</t>

      <figure><artwork><![CDATA[
   HTTP/1.1 403 Forbidden
   Content-Type: text/html
   Content-Language: en
   Link: <http://example.com/probs/out-of-credit>; rel="describedBy";
            title="You do not have enough credits."; balance=30;
            account="http://api.example.com/account/12345"
]]></artwork></figure>

      <t>Here, the same problem as above is conveyed using the header in
      previous examples, but without the optional detail.</t>

      <t>HTTP Problems are serialised into Link headers using the
      "describedBy" link relation type, with the URL for the problem type as
      the link target. The title is conveyed using the "title" parameter, 
      and the detail can be conveyed using the "detail" parameter.</t>
          
      <t>Extension parameters on the JSON Object can also be expressed as
      target parameters on the link header, as long as the extension either
      defines them as a string, or explains how to express them as one.</t>
       
      <t>The title, detail, and extension properties MUST use the encoding
      specified in <xref target="RFC5987"/> if it falls outside of the
      US-ASCII character set.</t>
      
      <t>For example, the following are all valid:</t>

      <figure><artwork><![CDATA[
   Link: <http://example.com/p/1>; rel="describedBy"; title="Hi"
   Link: <ftp://example.com/p/1>; rel="describedby"; title="Hi"
   Link: <http://example.com/p/1>; rel="describedby";
         title="Hi there"; detail="something happened."
   Link: <http://example.com/p/1>; rel="describedby"; other="foo";
         title="Hi there"; title*=UTF-8''Hi%20there; another=bar;
         detail*=UTF-8''something%20happened
]]></artwork></figure>

      </section>

      <section anchor="defining" title="Defining New HTTP Problems">

         <t>Before defining a new HTTP problem, it’s important to understand
         what they are good for, and what’s better left to other
         mechanisms.</t>
         
         <t>Problems are not a debugging tool for the underlying
         implementation; rather, they are a way to expose greater detail about
         the HTTP interface of the application itself.</t>
         
         <t>For example, an "out of credit" problem is an appropriate
         explanation as to why a request was forbidden. In contrast, an error
         explaining the internal conditions that led to a 500 Internal Server
         Error along with a stack trace is not an appropriate use of this
         mechanism, because it exposes implementation detail, rather than
         explaining the interface.</t>
                  
         <t>At the other end of the spectrum, truly generic problems – i.e.,
         conditions that could potentially apply to any resource on the Web –
         are usually better expressed as plain status codes.</t>

         <t>For example, a "write access disallowed" problem is likely
         unnecessary, since a 403 Forbidden status code on a PUT request is
         largely self-explanatory.</t>
         
         <t>If defining a new problem still seems wise, one can be created
         by:
         
         <list style="numbers">
            <t>Nominating a describedBy URL (typically, with the "http"
            scheme),</t>
            <t>Choosing a title that appropriately describes it (think
            short), and</t>
            <t>Nominating one or more HTTP status code that it should
            be used with.</t>
         </list></t>
         
         <t>Problems SHOULD document the HTTP status code(s) they are to be
         used with, and MAY specify the use of the Retry-After response header
         in appropriate circumstances.</t>
         
         <t>A problem’s describedBy URL SHOULD resolve to HTML documentation
         that explains how to resolve the problem.</t>
         
         <t>Optionally, a problem definition MAY specify additional properties
         on the HTTP Problem JSON object.</t>
         
         <t>For example, an extension might use typed links <xref
         target="RFC5988"/> to another resource that can be used by machines
         to resolve the problem.</t>
         
         <t>If an extension is defined, its name SHOULD conform to token <xref
         target="RFC2616"/>, so that it can be serialised in header and other
         formats.</t>
         
         <t>Likewise, problems defining extensions should either make their
         values strings, or explain how to map their values to strings that
         are safe to include in HTTP headers (noting the special semantics of
         a comma there).</t>

         </section>
         
         <section anchor="generating-problems" title="Generating
         Problems">
         
          <t>The URL used in the describedBy property MUST NOT be changed in
         any way from that defined by its specification; doing so turns it
         into a different problem that most consumers will not recognise.</t>
         
          <t>The title string SHOULD be sent as specified by the problem
         definition, although it MAY be localised (e.g., using server-driven
         content negotiation, with the "Accept-Language" request header).
         Remember that such responses are required by HTTP to include a Vary
         header, e.g.:</t>

      <figure><artwork><![CDATA[
   HTTP/1.1 403 Forbidden
   Content-Type: text/html
   Content-Language: se
   Vary: Accept-Language
   Link: <http://example.com/probs/out-of-credit>; rel="describedBy"; 
            title*=UTF-8''Du%20%C3%A4r%20ute%20p%C3%A5%20pengar.
]]></artwork></figure>

         <t>Note the use of RFC5987 encoding here. HTTP Problems SHOULD be
         served with Content-Language headers, even if negotiation isn't
         used, to aid in localisation.</t>

         <t>The information conveyed in the detail property, if present,
         SHOULD focus on helping the client correct the problem, rather than
         giving debugging information.</t>

          <t>Software that generates problems should note that only one
         problem can be sent at at time. </t>
         

      </section>

      <section anchor="consuming-problems" title="Consuming Problems">

         <t>Consumers should use the describedBy URL as the primary identifier
         for the problem; the title string is advisory, and included only for
         users who are not aware of the semantics of the URL, and don’t have
         the ability to discover them (e.g., offline log analysis).</t>
         
         <t>Likewise, the detail property SHOULD NOT be parsed for information
         by clients; extensions are more suitable and less error-prone ways to
         obtain such information.</t>

         <t>Clients consuming HTTP Problems MUST ignore unrecognised
         extensions; this allows problems to evolve and include additional
         information in the future. </t>

         <t>Finally, clients consuming HTTP Problems SHOULD NOT automatically
         deference the describedBy URL; it is not intended for machine
         interaction.</t>

      </section>
            
		<section title="Security Considerations">

         <t>When defining a new problem, the information included must be
         carefully vetted. Likewise, when actually generating a problem –
         however it is serialised – the details given must also be
         scrutinised.</t>
         
          <t>Risks include leaking information that can be exploited to
         compromise the system, an account in the system, or the privacy of
         users of the system.</t>

		</section>

		<section title="IANA Considerations">

<t>This specification defines a new Internet media type,
"application/json-problem":</t>

      <figure><artwork><![CDATA[
   Type name: application
   Subtype name: problem+json
   Required parameters: None
   Optional parameters: None; unrecognised parameters 
                        should be ignored
   Encoding considerations: Same as [RFC4627]
   Security considerations: see [this document]
   Interoperability considerations: None.
   Published specification: [this document]
   Applications that use this media type: HTTP
   Additional information:
     Magic number(s): n/a
     File extension(s): n/a
     Macintosh file type code(s): n/a
   Person & email address to contact for further information:
     Mark Nottingham <mnot@mnot.net>
   Intended usage: COMMON
   Restrictions on usage: None.
   Author: Mark Nottingham <mnot@mnot.net>
   Change controller: IESG
]]></artwork></figure>

		</section>
      
	</middle>

	<back>
		<references title="Normative References">
			&rfc2119;
			&rfc2616;
			&rfc3986;
			&rfc4627;
			&rfc5987;
			&rfc5988;
		</references>

<!--      <references title="Informative References">
		</references> -->



<section title="Non-Normative JSON Schema">

<t>This schema is non-normative, and will probably disappear unless JSON
   Schema actually starts moving forward.</t>

<figure><artwork><![CDATA[
   {
     "description": "HTTP Problem",
     "type": "object",
     "properties": {
       "describedBy": {
         "type": "string",
         "required": "true",
         "format": "uri"
       },
       "title": { "type": "string", required: true },
       "detail": { "type": "string" }
     }
   }
]]></artwork></figure>

</section>


	</back>
	

</rfc>
