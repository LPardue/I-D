<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.3 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-variant-00" category="std" updates="7234">

  <front>
    <title>HTTP Variants</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2017"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification introduces the HTTP <spanx style="verb">Variants</spanx> response header field to communicate what representations are available for a given resource.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/variant">https://github.com/mnot/I-D/labels/variant</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/variant/">https://mnot.github.io/I-D/variant/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/variant">https://github.com/mnot/I-D/commits/gh-pages/variant</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-variant/">https://datatracker.ietf.org/doc/draft-nottingham-variant/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP proactive content negotiation (<xref target="RFC7231"/>, Section 3.4.1) is increasingly being used to determine not only a response’s content-coding, but also its language, as well as newer axes (for example, see <xref target="I-D.ietf-httpbis-client-hints"/>).</t>

<t>Successfully reusing negotiated responses that have been stored in a HTTP cache requires establishment of a secondary cache key (<xref target="RFC7234"/>, Section 4.1) using the Vary header (<xref target="RFC7231"/>, Section 7.1.4), which identifies the request headers that form the secondary cache key for a given response.</t>

<t>HTTP’s caching model allows a certain amount of latitude in normalising request header fields to match those stored in the cache, so as to increase the chances of a cache hit while still respecting the semantics of that header. However, this is often inadequate; even with understanding of the headers’ semantics to facilitate such normalisation, a cache does not know enough about the possible alternative representations available on the origin server to make an appropriate decision.</t>

<t>For example, if a cache has stored the following request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: text/html
Content-Language: fr
Vary: Accept-Language
Transfer-Encoding: chunked

[French content]
]]></artwork></figure>

<t>Provided that the cache has full knowledge of the semantics of <spanx style="verb">Accept-Language</spanx> and <spanx style="verb">Content-Language</spanx>, it will know that a French representation is available and might be able to infer that an English representation is not available. But, it does not know (for example) whether a Japanese representation is available without making another request, thereby incurring possibly unnecessary latency.</t>

<t>This specification introduces the HTTP <spanx style="verb">Variants</spanx> response header field to provide caches with enough information to properly serve responses – either selected from cache or by forwarding them towards the origin – for content negotiation mechanisms with known semantics.</t>

<t><spanx style="verb">Variants</spanx> is best used when content negotiation takes place over a known, constrained set of representations. Since each variant needs to be listed in the header field, it is ill-suited for open-ended sets of representations. Likewise, it works best for content negotiation over header fields whose semantics are well-understood, since it requires a selection algorithm to be specified ahead of time.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in
<xref target="RFC2119"/>.</t>

<t>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> with a list extension, defined in Section 7 of <xref target="RFC7230"/>, that allows for compact definition of comma-separated lists using a ‘#’ operator (similar to how the ‘*’ operator indicates repetition).</t>

<t>Additionally, it uses the “field-name”, “OWS” and “token” rules from <xref target="RFC7230"/>.</t>

</section>
</section>
<section anchor="the-variants-http-header-field" title="The “Variants” HTTP Header Field">

<t>The <spanx style="verb">Variant</spanx> HTTP response header field is used to indicate what other representations are available for a given resource at the time that the response is produced.</t>

<figure><artwork><![CDATA[
Variants        = 1#variant
variant         = field-name *( OWS ";" OWS available-value )
available-value = token
]]></artwork></figure>

<t>Each <spanx style="verb">variant</spanx> indicates a response header field that carries a value that clients might proactively negotiate for; each parameter on it indicates a value for which there is an available representation on the origin server.</t>

<t>So, given this example header field:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip
]]></artwork></figure>

<t>a recipient can infer that the only content-coding available for that resource is “gzip” (along with the “identity” non-encoding; see {{content-encoding}).</t>

<t>Given:</t>

<figure><artwork><![CDATA[
Variants: content-encoding
]]></artwork></figure>

<t>a recipient can infer that no content-codings are supported. Note that as always with header field names, it is case-insensitive.</t>

<t>A more complex example:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;brotli, Content-Language;en ;fr
]]></artwork></figure>

<t>Here, recipients can infer that two Content-Encodings are available, as well as two content languages. Note that, as with all HTTP header fields that use the “#” list rule (see <xref target="RFC7230"/>, Section 7), they might occur in the same header field or separately, like this:</t>

<figure><artwork><![CDATA[
Variants: Content-Encoding;gzip;brotli
Variants: Content-Language;en ;fr
]]></artwork></figure>

<t>The ordering of available-values after the field-name is significant, as it might be used by the header’s algorithm for selecting a response.</t>

<t>Senders SHOULD consistently send <spanx style="verb">Variant</spanx> on all cacheable (as per <xref target="RFC7234"/>, Section 3) responses for a resource, since its absence will trigger caches to fall back to <spanx style="verb">Vary</spanx> processing.</t>

<t>Likewise, servers MUST send the <spanx style="verb">Content-*</spanx> response headers nominated by <spanx style="verb">Variants</spanx> when sending that header.</t>

<section anchor="defining-content-negotiation-using-variants" title="Defining Content Negotiation Using Variants">

<t>To be usable with Variants, proactive content negotiation mechanisms need to be specified to take advantage of it. Specifically, they:</t>

<t><list style="symbols">
  <t>MUST define a request header field that advertises the clients preferences or capabilities, whose field-name SHOULD begin with “Accept-“.</t>
  <t>MUST define a response header field that indicates the result of selection, whose field-name SHOULD begin with “Content-“ and whose field-value SHOULD be a token.</t>
  <t>MUST define an algorithm for selecting a result. It MUST return an ordered list of selected responses, given the incoming request, a list of selected responses, and the list of available values from <spanx style="verb">Variants</spanx>. If the result is an empty list, it implies that the cache does not contain an appropriate response.</t>
</list></t>

<t><xref target="backports"/> fulfils these requirements for some existing proactive content negotiation mechanisms in HTTP.</t>

<t>Note that unlike Vary, Variants does not use stored request headers to help select a response; this is why defining a response header to aid selection is required.</t>

</section>
<section anchor="cache" title="Cache Behaviour">

<t>Caches that implement the <spanx style="verb">Variants</spanx> header field and the relevant semantics of the field-name it contains can use that knowledge to either select an appropriate stored representation, or forward the request if no appropriate representation is stored.</t>

<t>They do so by running this algorithm (or its functional equivalent) upon receiving a request, <spanx style="verb">incoming-request</spanx>:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">selected-responses</spanx> be a list of the stored responses suitable for reuse as defined in <xref target="RFC7234"/> Section 4, excepting the requirement to calculate a secondary cache key.</t>
  <t>Order <spanx style="verb">selected-responses</spanx> by the “Date” header field, most recent to least recent.</t>
  <t>If the freshest (as per <xref target="RFC7234"/>, Section 4.2) has one or more <spanx style="verb">Variants</spanx> header field(s):
  <list style="numbers">
      <t>Select one member of <spanx style="verb">selected-responses</spanx> and let its “Variants” header field-value(s) be <spanx style="verb">Variants</spanx>. This SHOULD be the most recent response, but MAY be from an older one as long as it is still fresh.</t>
      <t>For each <spanx style="verb">variant</spanx> in <spanx style="verb">Variants</spanx>:
      <list style="numbers">
          <t>If the <spanx style="verb">field-name</spanx> corresponds to the response header field identified by a content negotiation mechanism that the implementation supports:
          <list style="numbers">
              <t>Let <spanx style="verb">available-values</spanx> be a list containing all <spanx style="verb">available-value</spanx> for the <spanx style="verb">variant</spanx>.</t>
              <t>Let <spanx style="verb">selected-responses</spanx> be the result of running the algorithm defined by the content negotiation mechanism with <spanx style="verb">incoming-request</spanx>, <spanx style="verb">selected-responses</spanx> and <spanx style="verb">available-values</spanx>.</t>
              <t>For the purposes of selecting a response, ignore the content negotiation’s identified request header field-name in the “Vary” header field of each member of <spanx style="verb">selected-responses</spanx>, if present.</t>
            </list></t>
        </list></t>
    </list></t>
  <t>Process any member of <spanx style="verb">selected-responses</spanx> that has a “Vary” response header field whose field-value still contains one or more <spanx style="verb">field-name</spanx>s, removing that members if it does not match (as per <xref target="RFC7234"/>, Section 4.1).</t>
  <t>Return the first member of <spanx style="verb">selected-responses</spanx>. If <spanx style="verb">selected-responses</spanx> is empty, return <spanx style="verb">null</spanx>.</t>
</list></t>

<t>This algorithm will either return the appropriate stored response to use, or <spanx style="verb">null</spanx> if the cache needs to forward the request towards the origin server.</t>

<section anchor="relationship-to-vary" title="Relationship to Vary">

<t>Caches that fully implement this specification MUST ignore request header-fields in the <spanx style="verb">Vary</spanx> header for the purposes of secondary cache key calculation (<xref target="RFC7234"/>, Section 4.1) when their semantics are understood, implemented as per this specification, and their corresponding response header field is listed in <spanx style="verb">Variants</spanx>.</t>

<t>Request header fields listed in <spanx style="verb">Vary</spanx> that are not implemented in terms of this specification or not present in the <spanx style="verb">Variants</spanx> field SHOULD still form part of the secondary cache key.</t>

<t>The algorithm in <xref target="cache"/> implements these requirements.</t>

</section>
</section>
<section anchor="examples" title="Examples">

<section anchor="single-variant" title="Single Variant">

<t>Given a request/response pair:</t>

<figure><artwork><![CDATA[
GET /foo HTTP/1.1
Host: www.example.com
Accept-Language: en;q=1.0, fr;q=0.5

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Cache-Control: max-age=3600
Variants: Content-Language;en;de
Vary: Accept-Language
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Upon receipt of this response, the cache knows that two representations of this resource are available, one with a <spanx style="verb">Content-Language</spanx> of “en”, and another whose <spanx style="verb">Content-Language</spanx> is “de”.</t>

<t>Subsequent requests (while this response is fresh) will cause the cache to either reuse this response or forward the request, depending on what the selection algorithm <spanx style="verb">Accept-Language</spanx> and <spanx style="verb">Content-Language</spanx> determines.</t>

<t>So, a request with “en” in <spanx style="verb">Accept-Language</spanx> is received and its q-value indicates that it is acceptable, the stored response is used. A request that indicates that “de” is acceptable will be forwarded to the origin, thereby populating the cache. A cache receiving a request that indicates both languages are acceptable will use the q-value to make a determination of what response to return.</t>

<t>A cache receiving a request that does not list either language as acceptable (or does not contain an Accept-Language at all) will return the “en” representation (possibly fetching it from the origin), since it is listed first in the <spanx style="verb">Variants</spanx> list.</t>

<t>Note that <spanx style="verb">Accept-Language</spanx> is listed in Vary, to assure backwards-compatibility with caches that do not support <spanx style="verb">Variants</spanx>.</t>

<t>Also, note that is is the response header which is listed in Variants, not the request header (the opposite of Vary).</t>

</section>
<section anchor="multiple-variants" title="Multiple Variants">

<t>A more complicated request/response pair:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Language;en;jp;de
Variants: Content-Encoding;br;gzip
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache knows that there are two axes that the response varies upon; <spanx style="verb">Content-Language</spanx> and <spanx style="verb">Content-Encoding</spanx>. Thus, there are a total of six possible representations for the resource, and the cache needs to consider the selection algorithms for both axes.</t>

<t>Upon a subsequent request, if both selection algorithms return a stored representation, it can be served from cache; otherwise, the request will need to be forwarded to origin.</t>

</section>
<section anchor="partial-coverage" title="Partial Coverage">

<t>Now, consider the previous example, but where only one of the varied axes is listed in <spanx style="verb">Variants</spanx>:</t>

<figure><artwork><![CDATA[
GET /bar HTTP/1.1
Host: www.example.net
Accept-Language: en;q=1.0, fr;q=0.5
Accept-Encoding: gzip, br

HTTP/1.1 200 OK
Content-Type: image/gif
Content-Language: en
Content-Encoding: br
Variants: Content-Encoding;br;gzip
Vary: Accept-Language, Accept-Encoding
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Here, the cache will need to calculate a secondary cache key as per <xref target="RFC7234"/>, Section 4.1 – but considering only <spanx style="verb">Accept-Language</spanx> to be in its field-value – and then continue processing <spanx style="verb">Variants</spanx> for the set of stored responses that the algorithm described there selects.</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This specification registers one value in the Permanent Message Header Field Names registry established by <xref target="RFC3864"/>:</t>

<t><list style="symbols">
  <t>Header field name: Variants</t>
  <t>Applicable protocol: http</t>
  <t>Status: standard</t>
  <t>Author/Change Controller: IETF</t>
  <t>Specification document(s): [this document]</t>
  <t>Related information:</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>If the number or advertised characteristics of the representations available for a resource are considered sensitive, the <spanx style="verb">Variants</spanx> header by its nature will leak them.</t>

<t>Note that the <spanx style="verb">Variants</spanx> header is not a commitment to make representations of a certain nature available; the runtime behaviour of the server always overrides hints like <spanx style="verb">Variants</spanx>.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>This protocol is conceptually similar to, but simpler than, Transparent Content Negotiation <xref target="RFC2295"/>. Thanks to its authors for their inspiration.</t>

<t>It is also a generalisation of a Fastly VCL feature designed by Rogier ‘DocWilco’ Mulhuijzen.</t>

<t>Thanks to Hooman Beheshti for his review and input.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC7231" target='https://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor="RFC7234" target='https://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC4647" target='https://www.rfc-editor.org/info/rfc4647'>
<front>
<title>Matching of Language Tags</title>
<author initials='A.' surname='Phillips' fullname='A. Phillips'><organization /></author>
<author initials='M.' surname='Davis' fullname='M. Davis'><organization /></author>
<date year='2006' month='September' />
<abstract><t>This document describes a syntax, called a &quot;language-range&quot;, for specifying items in a user's list of language preferences.  It also describes different mechanisms for comparing and matching these to language tags.  Two kinds of matching mechanisms, filtering and lookup, are defined.  Filtering produces a (potentially empty) set of language tags, whereas lookup produces a single language tag. Possible applications include language negotiation or content selection.  This document, in combination with RFC 4646, replaces RFC 3066, which replaced RFC 1766.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='47'/>
<seriesInfo name='RFC' value='4647'/>
<seriesInfo name='DOI' value='10.17487/RFC4647'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-httpbis-client-hints">
<front>
<title>HTTP Client Hints</title>

<author initials='I' surname='Grigorik' fullname='Ilya Grigorik'>
    <organization />
</author>

<date month='April' day='18' year='2017' />

<abstract><t>An increasing diversity of Web-connected devices and software capabilities has created a need to deliver optimized content for each device.  This specification defines a set of HTTP request header fields, colloquially known as Client Hints, to address this.  They are intended to be used as input to proactive content negotiation; just as the Accept header field allows user agents to indicate what formats they prefer, Client Hints allow user agents to indicate device and agent specific preferences.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-client-hints-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-client-hints-04.txt' />
</reference>



<reference  anchor="RFC3864" target='https://www.rfc-editor.org/info/rfc3864'>
<front>
<title>Registration Procedures for Message Header Fields</title>
<author initials='G.' surname='Klyne' fullname='G. Klyne'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='J.' surname='Mogul' fullname='J. Mogul'><organization /></author>
<date year='2004' month='September' />
<abstract><t>This specification defines registration procedures for the message header fields used by Internet mail, HTTP, Netnews and other applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='90'/>
<seriesInfo name='RFC' value='3864'/>
<seriesInfo name='DOI' value='10.17487/RFC3864'/>
</reference>



<reference  anchor="RFC2295" target='https://www.rfc-editor.org/info/rfc2295'>
<front>
<title>Transparent Content Negotiation in HTTP</title>
<author initials='K.' surname='Holtman' fullname='K. Holtman'><organization /></author>
<author initials='A.' surname='Mutz' fullname='A. Mutz'><organization /></author>
<date year='1998' month='March' />
<abstract><t>HTTP allows web site authors to put multiple versions of the same information under a single URL.  Transparent content negotiation is an extensible negotiation mechanism, layered on top of HTTP, for automatically selecting the best version when the URL is accessed.  This enables the smooth deployment of new web data formats and markup tags. This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested.</t></abstract>
</front>
<seriesInfo name='RFC' value='2295'/>
<seriesInfo name='DOI' value='10.17487/RFC2295'/>
</reference>




    </references>


<section anchor="backports" title="Variants and Defined Content Negotiation Mechanisms">

<t>This appendix defines the required information to use existing proactive content negotiation mechanisms (as defined in <xref target="RFC7231"/>, Section 5.3) with the <spanx style="verb">Variants</spanx> header field.</t>

<section anchor="content-encoding" title="Content-Encoding">

<t>When negotiating for the <spanx style="verb">Content-Encoding</spanx> response header field’s value, the applicable request header field is <spanx style="verb">Accept-Encoding</spanx>, as per <xref target="RFC7231"/> Section 5.3.4.</t>

<t>To perform content negotiation for Content-Encoding given an <spanx style="verb">incoming-request</spanx>, <spanx style="verb">stored-responses</spanx> and <spanx style="verb">available-values</spanx>:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">preferred-codings</spanx> be a list of the <spanx style="verb">coding</spanx>s in the “Accept-Encoding” header field of <spanx style="verb">incoming-request</spanx>, ordered by their <spanx style="verb">weight</spanx>, highest to lowest. If “Accept-Encoding” is not present or empty, <spanx style="verb">preferred-codings</spanx> will be empty.</t>
  <t>If <spanx style="verb">identity</spanx> is not a member of <spanx style="verb">preferred-codings</spanx>, append <spanx style="verb">identity</spanx> to <spanx style="verb">preferred-codings</spanx> with a <spanx style="verb">weight</spanx> of 0.001.</t>
  <t>Remove any member of <spanx style="verb">preferred-codings</spanx> whose <spanx style="verb">weight</spanx> is 0.</t>
  <t>Append “identity” to <spanx style="verb">available-values</spanx>.</t>
  <t>Remove any member of <spanx style="verb">available-values</spanx> not present in <spanx style="verb">preferred-codings</spanx>, comparing in a case-insensitive fashion.</t>
  <t>Let <spanx style="verb">filtered-responses</spanx> be an empty list.</t>
  <t>For each <spanx style="verb">available-value</spanx> of <spanx style="verb">available-values</spanx>:
  <list style="numbers">
      <t>If there is a member of <spanx style="verb">stored-responses</spanx> whose “Content-Encoding” field-value has <spanx style="verb">content-coding</spanx>s (<xref target="RFC7231"/>, Section 3.1.2.2) that all match members of <spanx style="verb">available-value</spanx> in a case-insensitive fashion, append that stored response to <spanx style="verb">filtered-responses</spanx>.</t>
    </list></t>
  <t>If there is a member of <spanx style="verb">stored-responses</spanx> that does not have a “Content-Encoding” header field, append that stored response to <spanx style="verb">filtered-responses</spanx>.</t>
  <t>Return <spanx style="verb">filtered-responses</spanx>.</t>
</list></t>

<t>This algorithm selects the stored response(s) in order of preference by the client; if none are stored in cache, the request will be forwarded towards the origin. It defaults to the “identity” non-encoding.</t>

<t>Implementations MAY remove members of <spanx style="verb">filtered-responses</spanx> based upon their <spanx style="verb">weight</spanx> or other criteria before returning. For example, they might wish to return an empty list when the client’s most-preferred available response is not stored, so as to populate the cache as well as honour the client’s preferences.</t>

</section>
<section anchor="content-language" title="Content-Language">

<t>When negotiating for the <spanx style="verb">Content-Language</spanx> response header field’s value, the applicable request header field is <spanx style="verb">Accept-Language</spanx>, as per <xref target="RFC7231"/> Section 5.3.5.</t>

<t>To perform content negotiation for Content-Language given an <spanx style="verb">incoming-request</spanx>, <spanx style="verb">stored-responses</spanx> and <spanx style="verb">available-values</spanx>:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">preferred-langs</spanx> be a list of the <spanx style="verb">language-range</spanx>s in the “Accept-Language” header field (<xref target="RFC7231"/>, Section 5.3.5) of <spanx style="verb">incoming-request</spanx>, ordered by their <spanx style="verb">weight</spanx>, highest to lowest.</t>
  <t>If <spanx style="verb">preferred-langs</spanx> is empty, append “*” with a <spanx style="verb">weight</spanx> of 0.001.</t>
  <t>Remove any member of <spanx style="verb">preferred-langs</spanx> whose <spanx style="verb">weight</spanx> is 0.</t>
  <t>Filter <spanx style="verb">available-values</spanx> using <spanx style="verb">preferred-langs</spanx> with either the Basic Filtering scheme defined in <xref target="RFC4647"/> Section 3.3.1, or the Lookup scheme defined in Section 3.4 of that document. Use the first member of <spanx style="verb">available-values</spanx> as the default.</t>
  <t>Let <spanx style="verb">filtered-responses</spanx> be an empty list.</t>
  <t>For each <spanx style="verb">available-value</spanx> of <spanx style="verb">available-values</spanx>:
  <list style="numbers">
      <t>If there is a member of <spanx style="verb">stored-responses</spanx> whose “Content-Language” field-value has a <spanx style="verb">language-tag</spanx> (<xref target="RFC7231"/>, Section 3.1.3.2) that matches <spanx style="verb">available-value</spanx> in a case-insensitive fashion, append that stored response to <spanx style="verb">filtered-responses</spanx>.</t>
    </list></t>
  <t>Return <spanx style="verb">filtered-responses</spanx>.</t>
</list></t>

<t>This algorithm selects the available response(s) (according to <spanx style="verb">Variants</spanx>) in order of preference by the client; if none are stored in cache, the request will be forwarded towards the origin. If no preferred language can be selected, the first <spanx style="verb">available-value</spanx> will be used as the default.</t>

<t>Implementations MAY remove members of <spanx style="verb">filtered-responses</spanx> based upon their <spanx style="verb">weight</spanx> or other criteria before returning. For example, they might wish to return an empty list when the client’s most-preferred available response is not stored, so as to populate the cache as well as honour the client’s preferences.</t>

</section>
</section>


  </back>

<!-- ##markdown-source:
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
Z6J90bu96NB+10j/P+3+5rT7P7498Xb0RgAA

-->

</rfc>

